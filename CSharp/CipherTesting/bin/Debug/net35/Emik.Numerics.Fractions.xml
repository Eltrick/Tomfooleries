<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Emik.Numerics.Fractions</name>
    </assembly>
    <members>
        <member name="T:System.Diagnostics.Contracts.PureAttribute">
            <summary>Indicates that a type or method is pure, that is, it does not make any visible state changes.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.AllowNullAttribute">
            <summary>Specifies that null is allowed as an input even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DisallowNullAttribute">
            <summary>Specifies that null is disallowed as an input even if the corresponding type allows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute">
            <summary>Applied to a method that will never return under any circumstance.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute">
            <summary>Specifies that the method will not return if the associated Boolean parameter is passed the specified value.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute"/> class
            with the specified parameter value.
            </summary>
            <param name="parameterValue">
            The condition parameter value. Code after the method will be considered unreachable by diagnostics if the argument to
            the associated parameter matches this value.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.DoesNotReturnIfAttribute.ParameterValue">
            <summary>
            Gets a value indicating whether the condition parameter value
            is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullAttribute">
            <summary>Specifies that an output may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullAttribute">
            <summary>Specifies that an output will not be null even if the corresponding type allows it. Specifies that an input argument was not null when the call returns.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute">
            <summary>Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue"/>, the parameter may be null even if the corresponding type disallows it.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute"/> class
            with the specified return value condition.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter may be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MaybeNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute">
            <summary>
            Specifies that when a method returns <see cref="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue"/>,
            the parameter will not be null even if the corresponding type allows it.
            </summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.#ctor(System.Boolean)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute"/> class
            with the specified return value condition.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute">
            <summary>Specifies that the output will be non-null if the named parameter is non-null.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute"/> class
            with the associated parameter name.
            </summary>
            <param name="parameterName">
            The associated parameter name.  The output will be non-null if the argument to the parameter specified is non-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.NotNullIfNotNullAttribute.ParameterName">
            <summary>Gets the associated parameter name.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute"/> class with a field or property member.
            </summary>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute"/> class
            with the list of field and property members.
            </summary>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute">
            <summary>Specifies that the method or property will ensure that the listed field and property members have not-null values when returning with the specified return value condition.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> class
            with the specified return value condition and a field or property member.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="member">
            The field or property member that is promised to be not-null.
            </param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.#ctor(System.Boolean,System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute"/> class
            with the specified return value condition and list of field and property members.
            </summary>
            <param name="returnValue">
            The return value condition. If the method returns this value, the associated parameter will not be null.
            </param>
            <param name="members">
            The list of field and property members that are promised to be not-null.
            </param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.ReturnValue">
            <summary>
            Gets a value indicating whether the return value condition is <see langword="true"/> or <see langword="false"/>.
            </summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.MemberNotNullWhenAttribute.Members">
            <summary>Gets field or property member names.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.SetsRequiredMembersAttribute">
            <summary>
            Specifies that this constructor sets all required members for the current type,
            and callers do not need to set any required members themselves.
            </summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute">
            <summary>Specifies the syntax used in a string.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.CompositeFormat">
            <summary>The syntax identifier for strings containing composite formats for string formatting.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateOnlyFormat">
            <summary>The syntax identifier for strings containing date format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.DateTimeFormat">
            <summary>The syntax identifier for strings containing date and time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.EnumFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Enum"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.GuidFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.Guid"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Json">
            <summary>The syntax identifier for strings containing JavaScript Object Notation (JSON).</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.NumericFormat">
            <summary>The syntax identifier for strings containing numeric format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Regex">
            <summary>The syntax identifier for strings containing regular expressions.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeOnlyFormat">
            <summary>The syntax identifier for strings containing time format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.TimeSpanFormat">
            <summary>The syntax identifier for strings containing <see cref="T:System.TimeSpan"/> format specifiers.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Uri">
            <summary>The syntax identifier for strings containing URIs.</summary>
        </member>
        <member name="F:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Xml">
            <summary>The syntax identifier for strings containing XML.</summary>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> class
            with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
        </member>
        <member name="M:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.#ctor(System.String,System.Object[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute"/> class
            with the identifier of the syntax used.
            </summary>
            <param name="syntax">The syntax identifier.</param>
            <param name="arguments">Optional arguments associated with the specific syntax employed.</param>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Syntax">
            <summary>Gets the identifier of the syntax used.</summary>
        </member>
        <member name="P:System.Diagnostics.CodeAnalysis.StringSyntaxAttribute.Arguments">
            <summary>Gets the optional arguments associated with the specific syntax employed.</summary>
        </member>
        <member name="T:System.Diagnostics.CodeAnalysis.UnscopedRefAttribute">
            <summary>Used to indicate a byref escapes and is not scoped.</summary>
        </member>
        <member name="T:System.Diagnostics.UnreachableException">
            <summary>Exception thrown when the program executes an instruction that was thought to be unreachable.</summary>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with the default error message.
            </summary>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with a specified error message.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
        </member>
        <member name="M:System.Diagnostics.UnreachableException.#ctor(System.String,System.Exception)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Diagnostics.UnreachableException"/> class with a specified error message
            and a reference to the inner exception that is the cause of this exception.
            </summary>
            <param name="message">The error message that explains the reason for the exception.</param>
            <param name="innerException">The exception that is the cause of the current exception.</param>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyCollection`1">
            <summary>Provides a read-only, covariant view of a generic list.</summary>
            <typeparam name="T">The type of item on the list.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyCollection`1.Count">
            <summary>Gets the amount of items on the list.</summary>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyDictionary`2">
            <summary>Represents a generic read-only collection of key/value pairs.</summary>
            <typeparam name="TKey">The type of keys in the read-only dictionary.</typeparam>
            <typeparam name="TValue">The type of values in the read-only dictionary.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Keys">
            <summary>Gets an enumerable collection that contains the keys in the read-only dictionary.</summary>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Values">
            <summary>Gets an enumerable collection that contains the values in the read-only dictionary.</summary>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyDictionary`2.Item(`0)">
            <summary>Gets the element that has the specified key in the read-only dictionary.</summary>
            <param name="key">The key to locate.</param>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)">
            <summary>Determines whether the read-only dictionary contains an element that has the specified key.</summary>
            <param name="key">The key to locate.</param>
            <returns>
            <see langword="true"/> if the read-only dictionary contains an element that has the specified key;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlyDictionary`2.TryGetValue(`0,`1@)">
            <summary>Gets the value that is associated with the specified key.</summary>
            <param name="key">The key to locate.</param>
            <param name="value">
            When this method returns, the value associated with the specified key, if the key is found;
            otherwise, the default value for the type of the <paramref name="value"/> parameter.
            This parameter is passed uninitialized.
            </param>
            <returns>
            <see langword="true"/> if the object that implements the <see cref="T:System.Collections.Generic.IReadOnlyDictionary`2"/>
            interface contains an element that has the specified key; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlyList`1">
            <summary>Represents a read-only collection of elements that can be accessed by index.</summary>
            <typeparam name="T">The type of elements in the read-only list.</typeparam>
        </member>
        <member name="P:System.Collections.Generic.IReadOnlyList`1.Item(System.Int32)">
            <summary>Performs an index operation on the list.</summary>
            <param name="index">The item to retrieve.</param>
        </member>
        <member name="T:System.Collections.Generic.IReadOnlySet`1">
            <summary>Provides a readonly abstraction of a set.</summary>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Contains(`0)">
            <summary>Determines if the set contains a specific item.</summary>
            <param name="item">The item to check if the set contains.</param>
            <returns><see langword="true"/> if found; otherwise <see langword="false"/>.</returns>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set is a proper subset of other; otherwise <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the collection is a proper superset of other; otherwise <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determine whether the current set is a subset of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determine whether the current set is a super set of a specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns><see langword="true"/> if the current set is a subset of other; otherwise <see langword="false"/>.</returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set overlaps with the specified collection.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set and other share at least one common element;
            otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.IReadOnlySet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <returns>
            <see langword="true"/> if the current set is equal to other; otherwise, <see langword="false"/>.
            </returns>
            <exception cref="T:System.ArgumentNullException">other is <see langword="null"/>.</exception>
        </member>
        <member name="T:System.Collections.Generic.ISet`1">
            <summary>Provides the base interface for the abstraction of sets.</summary>
            <remarks><para>
            This interface provides methods for implementing sets,
            which are collections that have unique elements and specific operations.
            </para></remarks>
            <typeparam name="T">The type of elements in the set.</typeparam>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>Removes all elements in the specified collection from the current set.</summary>
            <remarks><para>
            This method is an O(<c>n</c>) operation,
            where <c>n</c> is the number of elements in the <paramref name="other"/> parameter.
            </para></remarks>
            <param name="other">The collection of items to remove from the set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are also in a specified collection.
            </summary>
            <remarks><para>This method ignores any duplicate elements in other.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains only elements that are present
            either in the current set or in the specified collection, but not both.
            </summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <summary>
            Modifies the current set so that it contains all elements that are present in the current set,
            in the specified collection, or in both.
            </summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.Add(`0)">
            <summary>
            Adds an element to the current set and returns a value to indicate if the element was successfully added.
            </summary>
            <param name="item">The element to add to the set.</param>
            <returns>
            <see langword="true"/> if the element is added to the set;
            <see langword="false"/> if the element is already in the set.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) superset of a specified collection.</summary>
            <remarks><para>
            If the current set is a proper superset of <paramref name="other"/>,
            <paramref name="other"/> must have at least one element that the current set does not have.
            </para><para>
            An empty set is a proper superset of any other collection. Therefore, this method returns <see langword="true"/>
            if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
            </para><para>
            This method always returns <see langword="false"/> if the current set is
            less than or equal to the number of elements in <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a proper superset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a proper (strict) subset of a specified collection.</summary>
            <remarks><para>
            If the current set is a proper subset of <paramref name="other"/>,
            <paramref name="other"/> must have at least one element that the current set does not have.
            </para><para>
            An empty set is a proper subset of any other collection. Therefore, this method returns <see langword="true"/>
            if the current set is empty, unless the <paramref name="other"/> parameter is also an empty set.
            </para><para>
            This method always returns <see langword="false"/> if the current set has
            more or the same number of elements than <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a proper subset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether a set is a subset of a specified collection.</summary>
            <remarks><para>
            If <paramref name="other"/> contains the same elements as the current set,
            the current set is still considered a subset of <paramref name="other"/>.
            </para><para>
            This method always returns <see langword="false"/> if the current
            set has elements that are not in <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a subset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set is a superset of a specified collection.</summary>
            <remarks><para>
            If <paramref name="other"/> contains the same elements as the current set,
            the current set is still considered a superset of <paramref name="other"/>.
            </para><para>
            This method always returns <see langword="false"/> if the current
            set has fewer elements than <paramref name="other"/>.
            </para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is a superset of <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set overlaps with the specified collection.</summary>
            <remarks><para>Any duplicate elements in <paramref name="other"/> are ignored.</para></remarks>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set and <paramref name="other"/> share at least one common element;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <summary>Determines whether the current set and the specified collection contain the same elements.</summary>
            <param name="other">The collection to compare to the current set.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="other"/> is <see langword="null"/>.</exception>
            <returns>
            <see langword="true"/> if the current set is equal to <paramref name="other"/>;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="T:System.Linq.EnumerableZip">
            <summary>The backport of Zip methods for <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
        </member>
        <member name="M:System.Linq.EnumerableZip.Zip``2(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1})">
            <summary>
            Produces a sequence of tuples with elements from the two specified sequences.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
            <param name="first">The first sequence to merge.</param>
            <param name="second">The second sequence to merge.</param>
            <returns>A sequence of tuples with elements taken from the first and second sequence, in that order.</returns>
        </member>
        <member name="M:System.Linq.EnumerableZip.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Func{``0,``1,``2})">
            <summary>
            Applies a specified function to the corresponding elements of two sequences,
            producing a sequence of the results.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
            <typeparam name="TResult">The type of the elements of the result sequence.</typeparam>
            <param name="first">The first sequence to merge.</param>
            <param name="second">The second sequence to merge.</param>
            <param name="resultSelector">A function that specifies how to merge the elements from the two sequences.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> that contains merged elements of two input sequences.</returns>
        </member>
        <member name="M:System.Linq.EnumerableZip.Zip``3(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{``1},System.Collections.Generic.IEnumerable{``2})">
            <summary>
            Produces a sequence of tuples with elements from the three specified sequences.
            </summary>
            <typeparam name="TFirst">The type of the elements of the first input sequence.</typeparam>
            <typeparam name="TSecond">The type of the elements of the second input sequence.</typeparam>
            <typeparam name="TThird">The type of the elements of the third input sequence.</typeparam>
            <param name="first">The first sequence to merge.</param>
            <param name="second">The second sequence to merge.</param>
            <param name="third">The third sequence to merge.</param>
            <returns>
            A sequence of tuples with elements taken from the first, second, and third sequences, in that order.
            </returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.IsExternalInit">
            <summary>
            Reserved to be used by the compiler for tracking metadata.
            This class should not be used by developers in source code.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute">
            <summary>
            Indicates the type of the async method builder that should be used by a language compiler to
            build the attributed async method or to build the attributed type when used as the return type
            of an async method.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.#ctor(System.Type)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute"/> class.</summary>
            <param name="builderType">The <see cref="T:System.Type"/> of the associated builder.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.AsyncMethodBuilderAttribute.BuilderType">
            <summary>Gets the <see cref="T:System.Type"/> of the associated builder.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerAttribute">
            <summary>Indicates the attributed type is to be used as an interpolated string handler.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute">
            <summary>
            Indicates which arguments to a method involving an interpolated string handler should be passed to that handler.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <remarks><para>
            The empty string may be used as the name of the receiver in an instance method.
            </para></remarks>
            <param name="argument">The name of the argument that should be passed to the handler.</param>
        </member>
        <member name="M:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute"/> class.
            </summary>
            <remarks><para>
            The empty string may be used as the name of the receiver in an instance method.
            </para></remarks>
            <param name="arguments">The names of the arguments that should be passed to the handler.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.InterpolatedStringHandlerArgumentAttribute.Arguments">
            <summary>Gets the names of the arguments that should be passed to the handler.</summary>
            <remarks><para>
            The empty string may be used as the name of the receiver in an instance method.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.ModuleInitializerAttribute">
            <summary>
            Used to indicate to the compiler that a method should be called in its containing module's initializer.
            </summary>
            <remarks><para>
            When one or more valid methods with this attribute are found in a compilation,
            the compiler will emit a module initializer that calls each of the attributed methods.<br />
            Certain requirements are imposed on any method targeted with this attribute:
            </para><list type="bullet">
            <item><description>The method must be <see langword="static"/>.</description></item>
            <item><description>
            The method must be an ordinary member method, as opposed to a property accessor,
            constructor, local function, and so on.
            </description></item>
            <item><description>The method must be parameterless..</description></item>
            <item><description>The method must return <see langword="void"/>.</description></item>
            <item><description>The method must not be generic or be contained in a generic type.</description></item>
            <item><description>
            The method's effective accessibility must be <see langword="internal"/> or <see langword="public"/>.
            </description></item>
            </list><para>
            For more information, see
            https://github.com/dotnet/runtime/blob/main/docs/design/specs/Ecma-335-Augments.md#module-initializer.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerFilePathAttribute">
            <inheritdoc />
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerLineNumberAttribute">
            <inheritdoc />
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerMemberNameAttribute">
            <inheritdoc />
        </member>
        <member name="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute">
            <summary>Indicates that a parameter captures the expression passed for another parameter as a string.</summary>
            <remarks><para>This attribute is implemented in the compiler for C# 10 and later versions only.</para></remarks>
        </member>
        <member name="M:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute"/> class.</summary>
            <param name="parameterName">The name of the parameter whose expression should be captured as a string.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CallerArgumentExpressionAttribute.ParameterName">
            <summary>Gets the name of the parameter whose expression should be captured as a string.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.SkipLocalsInitAttribute">
            <summary>
            Used to indicate to the compiler that the <c>.locals init</c> flag should not be set in method headers.
            </summary>
            <remarks><para>
            This attribute is unsafe because it may reveal uninitialized memory to the application in certain
            instances (e.g., reading from uninitialized stackalloc'd memory). If applied to a method directly,
            the attribute applies to that method and all nested functions (lambdas, local functions) below it.
            If applied to a type or module, it applies to all methods nested inside. This attribute is intentionally
            not permitted on assemblies. Use at the module level instead to apply to multiple type declarations.
            </para></remarks>
        </member>
        <member name="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute">
            <summary>
            Indicates that compiler support for a particular feature is
            required for the location where this attribute is applied.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RefStructs">
            <summary>The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the ref structs C# feature.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.RequiredMembers">
            <summary>The <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/> used for the required members C# feature.</summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.#ctor(System.String)">
            <summary>Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute"/> class.</summary>
            <param name="featureName">The name of the compiler feature.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName">
            <summary>Gets the name of the compiler feature.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.IsOptional">
            <summary>
            Gets or sets a value indicating whether the compiler can choose to allow access to the location
            where this attribute is applied if it does not understand <see cref="P:System.Runtime.CompilerServices.CompilerFeatureRequiredAttribute.FeatureName"/>.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiredMemberAttribute">
            <summary>Specifies that a type has required members or that a member is required.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute">
            <summary>
            Indicates that an API is in preview. This attribute allows call sites to be
            flagged with a diagnostic that indicates that a preview feature is used.
            Authors can use this attribute to ship preview features in their assemblies.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.#ctor">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute"/> class.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.#ctor(System.String)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute"/> class
            with the specified message.
            </summary>
            <param name="message">An optional message associated with this attribute instance.</param>
        </member>
        <member name="P:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.Message">
            <summary>
            Gets the optional message associated with this attribute instance.
            </summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.RequiresPreviewFeaturesAttribute.Url">
            <summary>
            Gets or sets the optional URL associated with this attribute instance.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.MethodImplOptions">
            <summary>
            Specifies constants that define the details of how a method is implemented.
            This enumeration supports a bitwise combination of its member values.
            </summary>
            <remarks><para>
            This enumeration is used with the <see cref="T:System.Runtime.CompilerServices.MethodImplAttribute"/> attribute.
            You can specify multiple <see cref="T:System.Runtime.CompilerServices.MethodImplOptions"/> values by using the bitwise OR operator.
            </para></remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.Unmanaged">
            <summary>The method is implemented in unmanaged code.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.NoInlining">
            <summary>
            The method cannot be inlined.
            Inlining is an optimization by which a method call is replaced with the method body.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.ForwardRef">
            <summary>The method is declared, but its implementation is provided elsewhere.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.Synchronized">
            <summary>
            The method can be executed by only one thread at a time.
            Static methods lock on the type, whereas instance methods lock on the instance.
            Only one thread can execute in any of the instance functions,
            and only one thread can execute in any of a class's static functions.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.NoOptimization">
            <summary>
            The method is not optimized by the just-in-time (JIT) compiler or by native code generation (see Ngen.exe)
            when debugging possible code generation problems.
            </summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.PreserveSig">
            <summary>The method signature is exported exactly as declared.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveInlining">
            <summary>The method should be inlined if possible.</summary>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.AggressiveOptimization">
            <summary>The method contains code that should always be optimized by the just-in-time (JIT) compiler.</summary>
            <remarks><para>
            Use this attribute if running an unoptimized version of the method has undesirable effects,
            for instance causing too much overhead or extra memory allocation.
            </para><para>
            Methods with this attribute may not have optimal code generation.
            They bypass the first tier of Tiered Compilation and therefore can't benefit from optimizations that rely on
            tiering, for example, Dynamic PGO or optimizations based on initialized classes.
            </para></remarks>
        </member>
        <member name="F:System.Runtime.CompilerServices.MethodImplOptions.InternalCall">
            <summary>
            The call is internal, that is, it calls a method that's implemented within the common language runtime.
            </summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.RuntimeHelpers">
            <summary>
            Provides a set of static methods and properties that provide support for compilers. This class cannot be inherited.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.RuntimeHelpers.GetSubArray``1(``0[],System.Range)">
            <summary>Slices the specified array using the specified range.</summary>
            <typeparam name="T">The type of elements in the array.</typeparam>
            <param name="array">The array to slice.</param>
            <param name="range">
            An object that determines the portion of <paramref name="array"/> to include in the slice.
            </param>
            <returns>The subarray defined by <paramref name="range"/>.</returns>
        </member>
        <member name="T:System.Runtime.CompilerServices.ITuple">
            <summary>This interface is required for types that want to be indexed into by dynamic patterns.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Length">
            <summary>The number of positions in this data structure.</summary>
        </member>
        <member name="P:System.Runtime.CompilerServices.ITuple.Item(System.Int32)">
            <summary>Get the element at position <paramref name="index"/>.</summary>
        </member>
        <member name="T:System.Runtime.CompilerServices.TupleElementNamesAttribute">
            <summary>
            Indicates that the use of <see cref="T:System.ValueTuple" /> on a member is meant to be treated as a tuple with element names.
            </summary>
        </member>
        <member name="M:System.Runtime.CompilerServices.TupleElementNamesAttribute.#ctor(System.String[])">
            <summary>
            Initializes a new instance of the <see cref="T:System.Runtime.CompilerServices.TupleElementNamesAttribute" /> class.
            </summary>
            <param name="transformNames">
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueTuple" /> occurrences are
            meant to carry element names.
            </param>
            <remarks><para>
            This constructor is meant to be used on types that contain an
            instantiation of <see cref="T:System.ValueTuple" /> that contains
            element names.  For instance, if <c>C</c> is a generic type with
            two type parameters, then a use of the constructed type <c>C{<see cref="T:System.ValueTuple`2" />,
            <see cref="T:System.ValueTuple`3" /></c> might be intended to
            treat the first type argument as a tuple with element names and the
            second as a tuple without element names. In which case, the
            appropriate attribute specification should use a
            <paramref name="transformNames"/> value of <c>{ "name1", "name2", null, null,
            null }</c>.
            </para></remarks>
        </member>
        <member name="P:System.Runtime.CompilerServices.TupleElementNamesAttribute.TransformNames">
            <summary>
            Specifies, in a pre-order depth-first traversal of a type's
            construction, which <see cref="T:System.ValueTuple" /> elements are
            meant to carry element names.
            </summary>
        </member>
        <member name="T:System.Index">
            <summary>Represent a type can be used to index a collection either from the start or the end.</summary>
            <remarks><para>
            Index is used by the C# compiler to support the new index syntax.
            </para><code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 } ;
            int lastElement = someArray[^1]; // lastElement = 5
            </code></remarks>
        </member>
        <member name="M:System.Index.#ctor(System.Int32,System.Boolean)">
            <summary>Construct an Index using a value and indicating if the index is from the start or from the end.</summary>
            <param name="value">The index value. it has to be zero or positive number.</param>
            <param name="fromEnd">Indicating if the index is from the start or from the end.</param>
            <remarks><para>
            If the Index constructed from the end, index value 1 means pointing at the last element and index value 0 means
            pointing at beyond last element.
            </para></remarks>
        </member>
        <member name="P:System.Index.Start">
            <summary>Create an Index pointing at first element.</summary>
        </member>
        <member name="P:System.Index.End">
            <summary>Create an Index pointing at beyond last element.</summary>
        </member>
        <member name="P:System.Index.IsFromEnd">
            <summary>Indicates whether the index is from the start or the end.</summary>
        </member>
        <member name="P:System.Index.Value">
            <summary>Returns the index value.</summary>
        </member>
        <member name="M:System.Index.op_Implicit(System.Int32)~System.Index">
            <summary>Converts integer number to an Index.</summary>
        </member>
        <member name="M:System.Index.FromEnd(System.Int32)">
            <summary>Create an Index from the end at the position indicated by the value.</summary>
            <param name="value">The index value from the end.</param>
        </member>
        <member name="M:System.Index.FromStart(System.Int32)">
            <summary>Create an Index from the start at the position indicated by the value.</summary>
            <param name="value">The index value from the start.</param>
        </member>
        <member name="M:System.Index.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Index.Equals(System.Index)">
            <inheritdoc />
        </member>
        <member name="M:System.Index.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Index.GetOffset(System.Int32)">
            <summary>Calculate the offset from the start using the giving collection length.</summary>
            <param name="length">
            The length of the collection that the Index will be used with. length has to be a positive value.
            </param>
            <remarks><para>
            For performance reasons, we don't validate the input length parameter and the returned offset value against
            negative values. We don't validate either the returned offset is greater than the input length.
            It is expected that Index be used with collections which always have non-negative length/count.
            If the returned offset is negative and then used to index a collection will get out of range exception which
            will be same affect as the validation.
            </para></remarks>
        </member>
        <member name="M:System.Index.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.Range">
            <summary>Represent a range has start and end indexes.</summary>
            <remarks><para>
            Range is used by the C# compiler to support the range syntax.
            </para><code>
            int[] someArray = new int[5] { 1, 2, 3, 4, 5 };
            int[] subArray1 = someArray[0..2]; // { 1, 2 }
            int[] subArray2 = someArray[1..^0]; // { 2, 3, 4, 5 }
            </code></remarks>
        </member>
        <member name="M:System.Range.#ctor(System.Index,System.Index)">
            <summary>Construct a Range object using the start and end indexes.</summary>
            <param name="start">Represent the inclusive start index of the range.</param>
            <param name="end">Represent the exclusive end index of the range.</param>
        </member>
        <member name="P:System.Range.All">
            <summary>Create a Range object starting from first element to the end.</summary>
        </member>
        <member name="P:System.Range.Start">
            <summary>Represent the inclusive start index of the Range.</summary>
        </member>
        <member name="P:System.Range.End">
            <summary>Represent the exclusive end index of the Range.</summary>
        </member>
        <member name="M:System.Range.EndAt(System.Index)">
            <summary>Create a Range object starting from first element in the collection to the end Index.</summary>
        </member>
        <member name="M:System.Range.StartAt(System.Index)">
            <summary>Create a Range object starting from start index to the end of the collection.</summary>
        </member>
        <member name="M:System.Range.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Range.Equals(System.Range)">
            <inheritdoc />
        </member>
        <member name="M:System.Range.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Range.ToString">
            <inheritdoc />
        </member>
        <member name="T:System.RangeMethodsWithoutValueTuples">
            <summary>Implements a <see cref="M:System.RangeMethodsWithoutValueTuples.GetOffsetAndLength(System.Range,System.Int32,System.Int32@,System.Int32@)"/> overload that doesn't rely on tuples.</summary>
        </member>
        <member name="M:System.RangeMethodsWithoutValueTuples.GetOffsetAndLength(System.Range,System.Int32,System.Int32@,System.Int32@)">
            <summary>Calculate the start offset and length of range object using a collection length.</summary>
            <remarks><para>
            For performance reasons, we don't validate the input length parameter against negative values.
            It is expected Range will be used with collections which always have non negative length/count.
            We validate the range is inside the length scope though.
            </para></remarks>
            <param name="range">The <see cref="T:System.Range"/> that contains the range of elements.</param>
            <param name="length">
            The length of the collection that the range will be used with.
            <paramref name="length"/> has to be a positive value.
            </param>
            <param name="outOffset">The resulting offset.</param>
            <param name="outLength">The resulting length.</param>
        </member>
        <member name="T:System.Span`1">
            <summary>Provides a type-safe and memory-safe representation of a contiguous region of arbitrary memory.</summary>
            <remarks><para>This type delegates the responsibility of pinning the pointer to the consumer.</para></remarks>
            <typeparam name="T">The type of items in the <see cref="T:System.Span`1"/>.</typeparam>
        </member>
        <member name="F:System.Span`1._pointer">
            <summary>Gets the pointer representing the first element in the buffer.</summary>
        </member>
        <member name="M:System.Span`1.#ctor(System.Void*,System.Int32)">
            <summary>
            Initializes a new instance of the <see cref="T:System.Span`1"/> struct from a specified number of
            <typeparamref name="T"/> elements starting at a specified memory address.
            </summary>
            <param name="pointer">A pointer to the starting address of a specified number of T elements in memory.</param>
            <param name="length">The length of the buffer.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="length"/> is negative.</exception>
        </member>
        <member name="P:System.Span`1.Item(System.Int32)">
            <summary>Gets the element at the specified zero-based index.</summary>
            <param name="index">The zero-based index of the element.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="index"/> is less than zero or is greater than or equal to <see cref="P:System.Span`1.Length"/>.
            </exception>
        </member>
        <member name="P:System.Span`1.Empty">
            <summary>Gets an empty <see cref="T:System.Span`1"/> object.</summary>
        </member>
        <member name="P:System.Span`1.IsEmpty">
            <summary>Gets a value indicating whether the current <see cref="T:System.Span`1"/> is empty.</summary>
        </member>
        <member name="P:System.Span`1.Length">
            <summary>Gets the length of the current span.</summary>
        </member>
        <member name="M:System.Span`1.op_Equality(System.Span{`0},System.Span{`0})">
            <summary>Returns a value that indicates whether two <see cref="T:System.Span`1"/> objects are equal.</summary>
            <remarks><para>
            Two <see cref="T:System.Span`1"/> objects are equal if they have the same length and the corresponding elements of
            <paramref name="left"/> and <paramref name="right"/> point to the same memory. Note that the test for equality
            does <i>not</i> attempt to determine whether the contents are equal.
            </para></remarks>
            <param name="left">The first span to compare.</param>
            <param name="right">The second span to compare.</param>
            <returns>
            <see langword="true"/> if the two <see cref="T:System.Span`1"/> objects are equal; otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Span`1.op_Inequality(System.Span{`0},System.Span{`0})">
            <summary>Returns a value that indicates whether two <see cref="T:System.Span`1"/> objects are not equal.</summary>
            <remarks><para>
            Two <see cref="T:System.Span`1"/> objects are equal if they have the same length and the corresponding elements of
            <paramref name="left"/> and <paramref name="right"/> point to the same memory.
            </para></remarks>
            <param name="left">The first span to compare.</param>
            <param name="right">The second span to compare.</param>
            <returns>
            <see langword="true"/> if the two <see cref="T:System.Span`1"/> objects are not equal;
            otherwise, <see langword="false"/>.
            </returns>
        </member>
        <member name="M:System.Span`1.Clear">
            <summary>Clears the contents of this <see cref="T:System.Span`1"/> object.</summary>
            <remarks><para>
            The <see cref="M:System.Span`1.Clear"/> method sets the items in the <see cref="T:System.Span`1"/> object to their default values.
            It does not remove items from the <see cref="T:System.Span`1"/>.
            </para></remarks>
        </member>
        <member name="M:System.Span`1.CopyTo(System.Span{`0})">
            <summary>Copies the contents of this <see cref="T:System.Span`1"/> into a destination <see cref="T:System.Span`1"/>.</summary>
            <param name="destination">The destination <see cref="T:System.Span`1"/> object.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="destination"/> is shorter than the source <see cref="T:System.Span`1"/>.
            </exception>
        </member>
        <member name="M:System.Span`1.CopyTo(System.Collections.Generic.IList{`0})">
            <summary>Copies the contents of this <see cref="T:System.Span`1"/> into a destination <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <param name="destination">The destination <see cref="T:System.Collections.Generic.IList`1"/> object.</param>
            <exception cref="T:System.ArgumentException">
            <paramref name="destination"/> is shorter than the source <see cref="T:System.Span`1"/>.
            </exception>
        </member>
        <member name="M:System.Span`1.Fill(`0)">
            <summary>Fills the elements of this span with a specified value.</summary>
            <param name="value">The value to assign to each element of the span.</param>
        </member>
        <member name="M:System.Span`1.Equals(System.Object)">
            <inheritdoc />
        </member>
        <member name="M:System.Span`1.TryCopyTo(System.Span{`0})">
            <summary>
            Attempts to copy the current <see cref="T:System.Span`1"/> to a destination <see cref="T:System.Span`1"/>
            and returns a value that indicates whether the copy operation succeeded.
            </summary>
            <remarks><para>
            This method copies all of <c>source</c> to <paramref name="destination"/> even if
            <c>source</c> and <paramref name="destination"/> overlap.
            If <paramref name="destination"/> is shorter than the source <see cref="T:System.Span`1"/>, this method returns
            <see langword="false"/>, and no data is written to <paramref name="destination"/>.
            </para></remarks>
            <param name="destination">The target of the copy operation.</param>
            <returns><see langword="true"/> if the copy operation succeeded; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:System.Span`1.TryCopyTo(System.Collections.Generic.IList{`0})">
            <inheritdoc cref="M:System.Span`1.TryCopyTo(System.Span{`0})"/>
        </member>
        <member name="M:System.Span`1.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:System.Span`1.ToString">
            <inheritdoc />
        </member>
        <member name="M:System.Span`1.GetEnumerator">
            <summary>Returns an enumerator of this <see cref="T:System.Span`1"/>.</summary>
            <returns>An enumerator for this span.</returns>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32)">
            <summary>Forms a slice out of the current span that begins at a specified index.</summary>
            <param name="start">The index at which to begin the slice.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            <paramref name="start"/> is less than zero or greater than <see cref="P:System.Span`1.Length"/>.
            </exception>
            <returns>
            A span that consists of all elements of the current span from <paramref name="start"/> to the end of the span.
            </returns>
        </member>
        <member name="M:System.Span`1.Slice(System.Int32,System.Int32)">
            <summary>Creates the slice of this buffer.</summary>
            <param name="start">The start of the slice from this buffer.</param>
            <param name="length">The length of the slice from this buffer.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">An out-of-range buffer is created.</exception>
            <returns>The <see cref="T:System.Span`1"/> which is a slice of this buffer.</returns>
        </member>
        <member name="M:System.Span`1.ToArray">
            <summary>Copies the contents of this span into a new array.</summary>
            <remarks><para>
            This method performs a heap allocation and therefore should be avoided if possible.
            Heap allocations are expected in APIs that work with arrays.
            Using such APIs is unavoidable if an alternative API overhead that takes a <see cref="T:System.Span`1"/> does not exist.
            </para></remarks>
            <returns>An array containing the data in the current span.</returns>
        </member>
        <member name="T:System.Span`1.Enumerator">
            <summary>Enumerates the elements of a <see cref="T:System.Span`1"/>.</summary>
        </member>
        <member name="M:System.Span`1.Enumerator.#ctor(System.Span{`0})">
            <summary>Initializes a new instance of the <see cref="T:System.Span`1.Enumerator"/> struct.</summary>
            <param name="span">The buffer to peek through.</param>
        </member>
        <member name="P:System.Span`1.Enumerator.Current">
            <inheritdoc cref="P:System.Collections.Generic.IEnumerator`1.Current" />
        </member>
        <member name="M:System.Span`1.Enumerator.Reset">
            <inheritdoc cref="M:System.Collections.IEnumerator.Reset" />
        </member>
        <member name="M:System.Span`1.Enumerator.MoveNext">
            <inheritdoc cref="M:System.Collections.IEnumerator.MoveNext" />
        </member>
        <member name="T:System.IValueTupleInternal">
            <summary>
            Helper so we can call some tuple methods recursively without knowing the underlying types.
            </summary>
        </member>
        <member name="T:System.ValueTuple">
            <summary>
            The ValueTuple types (from arity 0 to 8) comprise the runtime implementation that underlies tuples in C# and struct tuples in F#.
            Aside from created via language syntax, they are most easily created via the ValueTuple.Create factory methods.
            The System.ValueTuple types differ from the System.Tuple types in that:
            - they are structs rather than classes,
            - they are mutable rather than readonly, and
            - their members (such as Item1, Item2, etc) are fields rather than properties.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if <paramref name="obj"/> is a <see cref="T:System.ValueTuple"/>.</returns>
        </member>
        <member name="M:System.ValueTuple.Equals(System.ValueTuple)">
            <summary>Returns a value indicating whether this instance is equal to a specified value.</summary>
            <param name="other">An instance to compare to this instance.</param>
            <returns>true if <paramref name="other"/> has the same value as this instance; otherwise, false.</returns>
        </member>
        <member name="M:System.ValueTuple.CompareTo(System.ValueTuple)">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple.GetHashCode">
            <summary>Returns the hash code for this instance.</summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>()</c>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="M:System.ValueTuple.Create">
            <summary>Creates a new struct 0-tuple.</summary>
            <returns>A 0-tuple.</returns>
        </member>
        <member name="M:System.ValueTuple.Create``1(``0)">
            <summary>Creates a new struct 1-tuple, or singleton.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <returns>A 1-tuple (singleton) whose value is (item1).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``2(``0,``1)">
            <summary>Creates a new struct 2-tuple, or pair.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <returns>A 2-tuple (pair) whose value is (item1, item2).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``3(``0,``1,``2)">
            <summary>Creates a new struct 3-tuple, or triple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <returns>A 3-tuple (triple) whose value is (item1, item2, item3).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``4(``0,``1,``2,``3)">
            <summary>Creates a new struct 4-tuple, or quadruple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <returns>A 4-tuple (quadruple) whose value is (item1, item2, item3, item4).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``5(``0,``1,``2,``3,``4)">
            <summary>Creates a new struct 5-tuple, or quintuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <returns>A 5-tuple (quintuple) whose value is (item1, item2, item3, item4, item5).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``6(``0,``1,``2,``3,``4,``5)">
            <summary>Creates a new struct 6-tuple, or sextuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <returns>A 6-tuple (sextuple) whose value is (item1, item2, item3, item4, item5, item6).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``7(``0,``1,``2,``3,``4,``5,``6)">
            <summary>Creates a new struct 7-tuple, or septuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <returns>A 7-tuple (septuple) whose value is (item1, item2, item3, item4, item5, item6, item7).</returns>
        </member>
        <member name="M:System.ValueTuple.Create``8(``0,``1,``2,``3,``4,``5,``6,``7)">
            <summary>Creates a new struct 8-tuple, or octuple.</summary>
            <typeparam name="T1">The type of the first component of the tuple.</typeparam>
            <typeparam name="T2">The type of the second component of the tuple.</typeparam>
            <typeparam name="T3">The type of the third component of the tuple.</typeparam>
            <typeparam name="T4">The type of the fourth component of the tuple.</typeparam>
            <typeparam name="T5">The type of the fifth component of the tuple.</typeparam>
            <typeparam name="T6">The type of the sixth component of the tuple.</typeparam>
            <typeparam name="T7">The type of the seventh component of the tuple.</typeparam>
            <typeparam name="T8">The type of the eighth component of the tuple.</typeparam>
            <param name="item1">The value of the first component of the tuple.</param>
            <param name="item2">The value of the second component of the tuple.</param>
            <param name="item3">The value of the third component of the tuple.</param>
            <param name="item4">The value of the fourth component of the tuple.</param>
            <param name="item5">The value of the fifth component of the tuple.</param>
            <param name="item6">The value of the sixth component of the tuple.</param>
            <param name="item7">The value of the seventh component of the tuple.</param>
            <param name="item8">The value of the eighth component of the tuple.</param>
            <returns>An 8-tuple (octuple) whose value is (item1, item2, item3, item4, item5, item6, item7, item8).</returns>
        </member>
        <member name="T:System.ValueTuple`1">
            <summary>Represents a 1-tuple, or singleton, as a value type.</summary>
            <typeparam name="T1">The type of the tuple's only component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`1.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`1"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`1"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`1"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.Equals(System.ValueTuple{`0})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`1"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`1"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its field
            is equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`1.CompareTo(System.ValueTuple{`0})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`1.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`1.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`1"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`1"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1)</c>,
            where <c>Item1</c> represents the value of <see cref="F:System.ValueTuple`1.Item1"/>. If the field is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`1.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`2">
            <summary>
            Represents a 2-tuple, or pair, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`2.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`2.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`2"/> instance's first component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`2.#ctor(`0,`1)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`2"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.Object)">
             <summary>
             Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified object.
             </summary>
             <param name="obj">The object to compare with this instance.</param>
             <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            
             <remarks>
             The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
             <list type="bullet">
                 <item><description>It is a <see cref="T:System.ValueTuple`2"/> value type.</description></item>
                 <item><description>Its components are of the same types as those of the current instance.</description></item>
                 <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
             </list>
             </remarks>
        </member>
        <member name="M:System.ValueTuple`2.Equals(System.ValueTuple{`0,`1})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`2"/> instance is equal to a specified <see cref="T:System.ValueTuple`2"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`2.CompareTo(System.ValueTuple{`0,`1})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`2.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`2.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`2"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`2"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2)</c>,
            where <c>Item1</c> and <c>Item2</c> represent the values of the <see cref="F:System.ValueTuple`2.Item1"/>
            and <see cref="F:System.ValueTuple`2.Item2"/> fields. If either field value is <see langword="null"/>,
            it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`2.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`3">
            <summary>
            Represents a 3-tuple, or triple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`3.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`3.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`3"/> instance's third component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`3.#ctor(`0,`1,`2)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`3"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`3"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.Equals(System.ValueTuple{`0,`1,`2})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`3"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`3"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`3.CompareTo(System.ValueTuple{`0,`1,`2})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`3.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`3.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`3"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`3"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`3.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`4">
            <summary>
            Represents a 4-tuple, or quadruple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`4.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`4.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`4"/> instance's fourth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`4.#ctor(`0,`1,`2,`3)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`4"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`4"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.Equals(System.ValueTuple{`0,`1,`2,`3})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`4"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`4"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`4.CompareTo(System.ValueTuple{`0,`1,`2,`3})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`4.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`4.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`4"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`4"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`4.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`5">
            <summary>
            Represents a 5-tuple, or quintuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`5.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`5.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`5"/> instance's fifth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`5.#ctor(`0,`1,`2,`3,`4)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`5"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`5"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.Equals(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`5"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`5"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`5.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`5.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`5.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`5"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`5"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`5.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`6">
            <summary>
            Represents a 6-tuple, or sixtuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`6.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`6.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`6"/> instance's sixth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`6.#ctor(`0,`1,`2,`3,`4,`5)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`6"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`6"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`6"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`6"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`6.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`6.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`6.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`6"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`6"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`6.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`7">
            <summary>
            Represents a 7-tuple, or sentuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`7.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`7.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`7"/> instance's seventh component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`7.#ctor(`0,`1,`2,`3,`4,`5,`6)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`7"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`7"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`7"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`7"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`7.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`7.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`7.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`7"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`7"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`7.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.ValueTuple`8">
            <summary>
            Represents an 8-tuple, or octuple, as a value type.
            </summary>
            <typeparam name="T1">The type of the tuple's first component.</typeparam>
            <typeparam name="T2">The type of the tuple's second component.</typeparam>
            <typeparam name="T3">The type of the tuple's third component.</typeparam>
            <typeparam name="T4">The type of the tuple's fourth component.</typeparam>
            <typeparam name="T5">The type of the tuple's fifth component.</typeparam>
            <typeparam name="T6">The type of the tuple's sixth component.</typeparam>
            <typeparam name="T7">The type of the tuple's seventh component.</typeparam>
            <typeparam name="TRest">The type of the tuple's eighth component.</typeparam>
        </member>
        <member name="F:System.ValueTuple`8.Item1">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's first component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item2">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's second component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item3">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's third component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item4">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fourth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item5">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's fifth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item6">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's sixth component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Item7">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's seventh component.
            </summary>
        </member>
        <member name="F:System.ValueTuple`8.Rest">
            <summary>
            The current <see cref="T:System.ValueTuple`8"/> instance's eighth component.
            </summary>
        </member>
        <member name="M:System.ValueTuple`8.#ctor(`0,`1,`2,`3,`4,`5,`6,`7)">
            <summary>
            Initializes a new instance of the <see cref="T:System.ValueTuple`8"/> value type.
            </summary>
            <param name="item1">The value of the tuple's first component.</param>
            <param name="item2">The value of the tuple's second component.</param>
            <param name="item3">The value of the tuple's third component.</param>
            <param name="item4">The value of the tuple's fourth component.</param>
            <param name="item5">The value of the tuple's fifth component.</param>
            <param name="item6">The value of the tuple's sixth component.</param>
            <param name="item7">The value of the tuple's seventh component.</param>
            <param name="rest">The value of the tuple's eight component.</param>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.Object)">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/> instance is equal to a specified object.
            </summary>
            <param name="obj">The object to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified object; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="obj"/> parameter is considered to be equal to the current instance under the following conditions:
            <list type="bullet">
                <item><description>It is a <see cref="T:System.ValueTuple`8"/> value type.</description></item>
                <item><description>Its components are of the same types as those of the current instance.</description></item>
                <item><description>Its components are equal to those of the current instance. Equality is determined by the default object equality comparer for each component.</description></item>
            </list>
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.Equals(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>
            Returns a value that indicates whether the current <see cref="T:System.ValueTuple`8"/>
            instance is equal to a specified <see cref="T:System.ValueTuple`8"/>.
            </summary>
            <param name="other">The tuple to compare with this instance.</param>
            <returns><see langword="true"/> if the current instance is equal to the specified tuple; otherwise, <see langword="false"/>.</returns>
            <remarks>
            The <paramref name="other"/> parameter is considered to be equal to the current instance if each of its fields
            are equal to that of the current instance, using the default comparer for that field's type.
            </remarks>
        </member>
        <member name="M:System.ValueTuple`8.CompareTo(System.ValueTuple{`0,`1,`2,`3,`4,`5,`6,`7})">
            <summary>Compares this instance to a specified instance and returns an indication of their relative values.</summary>
            <param name="other">An instance to compare.</param>
            <returns>
            A signed number indicating the relative values of this instance and <paramref name="other"/>.
            Returns less than zero if this instance is less than <paramref name="other"/>, zero if this
            instance is equal to <paramref name="other"/>, and greater than zero if this instance is greater
            than <paramref name="other"/>.
            </returns>
        </member>
        <member name="M:System.ValueTuple`8.GetHashCode">
            <summary>
            Returns the hash code for the current <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>A 32-bit signed integer hash code.</returns>
        </member>
        <member name="M:System.ValueTuple`8.ToString">
            <summary>
            Returns a string that represents the value of this <see cref="T:System.ValueTuple`8"/> instance.
            </summary>
            <returns>The string representation of this <see cref="T:System.ValueTuple`8"/> instance.</returns>
            <remarks>
            The string returned by this method takes the form <c>(Item1, Item2, Item3, Item4, Item5, Item6, Item7, Rest)</c>.
            If any field value is <see langword="null"/>, it is represented as <see cref="F:System.String.Empty"/>.
            </remarks>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Length">
            <summary>
            The number of positions in this data structure.
            </summary>
        </member>
        <member name="P:System.ValueTuple`8.System#Runtime#CompilerServices#ITuple#Item(System.Int32)">
            <summary>
            Get the element at position <param name="index"/>.
            </summary>
        </member>
        <member name="T:System.KeyValuePairDeconstructors">
            <summary>Allows a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> to be deconstructed, much like a tuple.</summary>
        </member>
        <member name="M:System.KeyValuePairDeconstructors.Deconstruct``2(System.Collections.Generic.KeyValuePair{``0,``1},``0@,``1@)">
            <summary>Deconstructs a <see cref="T:System.Collections.Generic.KeyValuePair`2"/> into its components.</summary>
            <typeparam name="TKey">The key generic in the <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <typeparam name="TValue">The value generic in the <see cref="T:System.Collections.Generic.KeyValuePair`2"/>.</typeparam>
            <param name="kvp">The key value pair to deconstruct.</param>
            <param name="key">The key value to get assigned as the key value pair's key.</param>
            <param name="value">The key value to get assigned as the key value pair's value.</param>
        </member>
        <member name="T:Emik.Morsels.Span">
            <summary>Defines methods for callbacks with spans. Methods here do not clear the allocated buffer.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
        </member>
        <member name="T:Emik.Morsels.Span.SpanAction`1">
            <summary>A callback for a span.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <param name="span">The allocated span.</param>
        </member>
        <member name="T:Emik.Morsels.Span.SpanAction`2">
            <summary>A callback for a span with a reference parameter.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <param name="span">The allocated span.</param>
            <param name="param">The parameter.</param>
        </member>
        <member name="T:Emik.Morsels.Span.SpanFunc`2">
            <summary>A callback for a span with a return value.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="span">The allocated span.</param>
            <returns>The returned value of this delegate.</returns>
        </member>
        <member name="T:Emik.Morsels.Span.SpanFunc`3">
            <summary>A callback for a span with a reference parameter with a return value.</summary>
            <typeparam name="TSpan">The inner type of the span.</typeparam>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="span">The allocated span.</param>
            <param name="param">The parameter.</param>
            <returns>The returned value of this delegate.</returns>
        </member>
        <member name="F:Emik.Morsels.Span.Stackalloc">
            <summary>The maximum size for the number of bytes a stack allocation will occur in this class.</summary>
            <remarks><para>
            Stack allocating arrays is an incredibly powerful tool that gets rid of a lot of the overhead that comes from
            instantiating arrays normally. Notably, that all classes (such as <see cref="T:System.Array"/> or <see cref="T:System.Collections.Generic.List`1"/>)
            are heap allocated, and moreover are garbage collected. This can put a strain in methods that are called often.
            </para><para>
            However, there isn't as much stack memory available as there is heap, which can cause a DoS (Denial of Service)
            vulnerability if you aren't careful. The methods in <c>Span</c> will automatically switch to unmanaged heap
            allocation if the type argument and length create an array that exceeds 1kB (1024 bytes).
            </para></remarks>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate(System.Int32,Emik.Morsels.Span.SpanAction{System.Byte})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
            <param name="length">The length of the buffer.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``1(System.Int32,Emik.Morsels.Span.SpanAction{``0})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``1(System.Int32,``0,Emik.Morsels.Span.SpanAction{System.Byte,``0})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,``1,Emik.Morsels.Span.SpanAction{``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.Span.IsStack``1(System.Int32)">
            <summary>Determines if a given length and type should be stack-allocated.</summary>
            <remarks><para>
            See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.
            </para></remarks>
            <typeparam name="T">The type of array.</typeparam>
            <param name="length">The amount of items.</param>
            <returns>
            The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Span.InBytes``1(System.Int32)">
            <summary>Gets the byte length needed to allocate the current length, used in <see cref="M:Emik.Morsels.Span.IsStack``1(System.Int32)"/>.</summary>
            <typeparam name="T">The type of array.</typeparam>
            <param name="length">The amount of items.</param>
            <returns>
            The value <see langword="true"/>, if it should be stack-allocated, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``1(System.Int32,Emik.Morsels.Span.SpanFunc{System.Byte,``0})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,Emik.Morsels.Span.SpanFunc{``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``2(System.Int32,``0,Emik.Morsels.Span.SpanFunc{System.Byte,``0,``1})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Span.Allocate``3(System.Int32,``1,Emik.Morsels.Span.SpanFunc{``0,``1,``2})">
            <summary>Allocates memory and calls the callback, passing in the <see cref="T:System.Span`1"/>.</summary>
            <remarks><para>See <see cref="F:Emik.Morsels.Span.Stackalloc"/> for details about stack- and heap-allocation.</para></remarks>
            <typeparam name="TSpan">The type of parameter in the span.</typeparam>
            <typeparam name="TParam">The type of the parameter.</typeparam>
            <typeparam name="TResult">The return type.</typeparam>
            <param name="length">The length of the buffer.</param>
            <param name="param">The parameter to pass in.</param>
            <param name="del">The callback to invoke.</param>
            <returns>The returned value from invoking <paramref name="del"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.CircularFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.CircularList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.CircularFactory.ToCircularLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.CircularList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.CircularList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.CircularList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.CircularList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where elements are treated as circular;
            indices wrap around and will therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.CircularList`1"/> class.</summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:Emik.Morsels.CircularList`1.Count"/> returns a non-positive number.</exception>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.CircularList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.CircularList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.ClippedFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.ClippedList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.ClippedFactory.ToClippedLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.ClippedList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.ClippedList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.ClippedList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ClippedList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where indices are always clamped and therefore never be out of range.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.ClippedList`1"/> class.</summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
            <exception cref="T:System.ArgumentOutOfRangeException"><see cref="P:Emik.Morsels.ClippedList`1.Count"/> returns a non-positive number.</exception>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.ClippedList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.ClippedList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.GuardedFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.GuardedList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.GuardedFactory.ToGuardedLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:Emik.Morsels.GuardedList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:Emik.Morsels.GuardedList`1"/>.</param>
            <returns>A <see cref="T:Emik.Morsels.GuardedList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.GuardedList`1">
            <summary>
            Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> where applying an index will always result in an optional value;
            an out of range value will always give the <see langword="default"/> value.
            </summary>
            <typeparam name="T">The generic type of the encapsulated <see cref="T:System.Collections.Generic.IList`1"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.GuardedList`1"/> class.</summary>
            <param name="list">The <see cref="T:System.Collections.Generic.IList`1"/> to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.IsReadOnly">
            <inheritdoc/>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.GuardedList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Add(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Clear">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Insert(System.Int32,`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.RemoveAt(System.Int32)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.Remove(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.IndexOf(`0)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Morsels.GuardedList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.MatrixFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Matrix`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.MatrixFactory.AsMatrix``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:Emik.Morsels.Matrix`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
            <param name="iterator">The collection to turn into a <see cref="T:Emik.Morsels.Matrix`1"/>.</param>
            <param name="countPerList">The length per count.</param>
            <returns>A <see cref="T:Emik.Morsels.Matrix`1"/> that wraps the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.MatrixFactory.AsMatrix``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> in a <see cref="T:Emik.Morsels.Matrix`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterator"/> and the <see langword="return"/>.</typeparam>
            <param name="iterator">The collection to turn into a <see cref="T:Emik.Morsels.Matrix`1"/>.</param>
            <param name="countPerList">The length per count.</param>
            <returns>A <see cref="T:Emik.Morsels.Matrix`1"/> that wraps the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Matrix`1">
            <summary>Maps a 1-dimensional collection as 2-dimensional.</summary>
            <typeparam name="T">The type of item within the list.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.#ctor(System.Collections.Generic.IList{`0},System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Matrix`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
            <param name="countPerList">The length per count.</param>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.#ctor(System.Collections.Generic.IList{`0},System.Func{System.Int32})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Matrix`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
            <param name="countPerList">The length per count.</param>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.#ctor(System.Func{System.Collections.Generic.IList{`0}},System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Matrix`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
            <param name="countPerList">The length per count.</param>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.#ctor(System.Func{System.Collections.Generic.IList{`0}},System.Func{System.Int32})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Matrix`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
            <param name="countPerList">The length per count.</param>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.CountPerList">
            <summary>Gets the amount of items per list.</summary>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.List">
            <summary>Gets the encapsulated list.</summary>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Matrix`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Count">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Add(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Contains(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.CopyTo(System.Collections.Generic.IList{`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Insert(System.Int32,System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Remove(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.IndexOf(System.Collections.Generic.IList{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Matrix`1.Slice">
            <summary>Represents a slice of a matrix.</summary>
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.#ctor(Emik.Morsels.Matrix{`0},System.Int32)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Matrix`1.Slice"/> class.</summary>
            <param name="matrix">The matrix to reference.</param>
            <param name="ordinal">The first index of the matrix.</param>
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Slice.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Slice.Count">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Matrix`1.Slice.Item(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Matrix`1.Slice.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Once`1">
            <summary>A factory for creating iterator types that yields an item once.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Once`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Once`1"/> struct. Prepares enumeration of a single item forever.
            </summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.Current">
            <summary>Gets the item to use.</summary>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)"/>
        </member>
        <member name="P:Emik.Morsels.Once`1.System#Collections#Generic#IReadOnlyList{T}#Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyList`1.Item(System.Int32)"/>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(`0)~Emik.Morsels.Once{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.op_Implicit(Emik.Morsels.Once{`0})~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Once`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Once`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IList{T}#RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#ExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#IntersectWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#SymmetricExceptWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#UnionWith(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Contains(`0)">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Contains(`0)"/>
        </member>
        <member name="M:Emik.Morsels.Once`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsProperSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSubsetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.IsSupersetOf(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.Overlaps(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.Overlaps(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.SetEquals(System.Collections.Generic.IEnumerable{`0})">
            <inheritdoc cref="M:System.Collections.Generic.ISet`1.SetEquals(System.Collections.Generic.IEnumerable{`0})" />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#ISet{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.GetEnumerator">
            <summary>
            Returns itself. Used to tell the compiler that it can be used in a <see langword="foreach"/> loop.
            </summary>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Once`1.Enumerator">
            <summary>An enumerator over <see cref="T:Emik.Morsels.Once`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Once`1.Enumerator"/> struct.
            Prepares enumeration of a single item forever.
            </summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Once`1.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Once`1.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.op_Implicit(`0)~Emik.Morsels.Once{`0}.Enumerator">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.op_Implicit(Emik.Morsels.Once{`0}.Enumerator)~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Once`1.Enumerator.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Once`1.Enumerator.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Once`1.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.OnceFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Once`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.OnceFactory.Yield``1(``0)">
            <summary>Creates a <see cref="T:Emik.Morsels.Once`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Once`1"/> instance that can be yielded once.</returns>
        </member>
        <member name="T:Emik.Morsels.ReadOnlyFactory">
            <summary>Extension methods that act as factories for <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.ReadOnlyFactory.ToReadOnly``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Wraps an <see cref="T:System.Collections.Generic.IList`1"/> (upcasted/created) to <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</summary>
            <typeparam name="T">The type of the <paramref name="iterable"/> and the <see langword="return"/>.</typeparam>
            <param name="iterable">The collection to turn into a <see cref="T:System.Collections.Generic.IReadOnlyList`1"/>.</param>
            <returns>A <see cref="T:System.Collections.Generic.IReadOnlyList`1"/> of <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ReadOnlyList`1">
            <summary>Encapsulates an <see cref="T:System.Collections.Generic.IList`1"/> and make all mutating methods a no-op.</summary>
            <typeparam name="T">The type of element in the list.</typeparam>
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.#ctor(System.Collections.Generic.IList{`0})">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.ReadOnlyList`1"/> class.</summary>
            <param name="list">The list to encapsulate.</param>
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.IsReadOnly">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count"/>
        </member>
        <member name="P:Emik.Morsels.ReadOnlyList`1.Item(System.Int32)">
            <inheritdoc cref="P:System.Collections.Generic.IList`1.Item(System.Int32)" />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Clear">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Insert(System.Int32,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.RemoveAt(System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.IndexOf(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.ReadOnlyList`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Yes`1">
            <summary>A factory for creating iterator types that yield the same item forever.</summary>
            <typeparam name="T">The type of the item to yield.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Yes`1.#ctor(`0)">
            <summary>
            Initializes a new instance of the <see cref="T:Emik.Morsels.Yes`1"/> struct. Prepares enumeration of a single item forever.
            </summary>
            <param name="value">The item to use.</param>
        </member>
        <member name="P:Emik.Morsels.Yes`1.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Yes`1.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.op_Implicit(`0)~Emik.Morsels.Yes{`0}">
            <summary>Implicitly calls the constructor.</summary>
            <param name="value">The value to pass into the constructor.</param>
            <returns>A new instance of <see cref="T:Emik.Morsels.Yes`1"/> with <paramref name="value"/> passed in.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.op_Implicit(Emik.Morsels.Yes{`0})~`0">
            <summary>Implicitly calls <see cref="P:Emik.Morsels.Yes`1.Current"/>.</summary>
            <param name="value">The value to call <see cref="P:Emik.Morsels.Yes`1.Current"/>.</param>
            <returns>The value that was passed in to this instance.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.GetEnumerator">
            <summary>Returns itself.</summary>
            <remarks><para>Used to allow <see langword="foreach"/> to be used on <see cref="T:Emik.Morsels.Yes`1"/>.</para></remarks>
            <returns>Itself.</returns>
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#IDisposable#Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerator#Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerator#MoveNext">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#Generic#IEnumerable{T}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Yes`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.YesFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Yes`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.YesFactory.Forever``1(``0)">
            <summary>Creates a <see cref="T:Emik.Morsels.Yes`1"/> from an item.</summary>
            <typeparam name="T">The type of item.</typeparam>
            <param name="source">The item.</param>
            <returns>The <see cref="T:Emik.Morsels.Yes`1"/> instance that can be yielded forever.</returns>
        </member>
        <member name="T:Emik.Morsels.NullableItems">
            <summary>Extension methods for improving nullability awareness for enumerables.</summary>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="iterable">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="iterable"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="iterator">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="iterator"/>, with <see cref="T:JetBrains.Annotations.ItemCanBeNullAttribute"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemNotNull``1(System.Collections.Generic.IList{``0})">
            <summary>Returns the list if all items are non-null.</summary>
            <typeparam name="T">The type of list.</typeparam>
            <param name="list">The list to filter.</param>
            <returns>
            The parameter <paramref name="list"/> if all items are non-<see langword="null"/>,
            otherwise <see langword="null"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="collection">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="collection"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlyList{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="list">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="list"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="M:Emik.Morsels.NullableItems.ItemCanBeNull``1(System.Collections.Generic.IReadOnlySet{``0})">
            <summary>Annotates <c>ItemCanBeNullAttribute</c>.</summary>
            <typeparam name="T">The type of item to adjust nullability.</typeparam>
            <param name="set">The item to return with adjusted nullability.</param>
            <returns>The parameter <paramref name="set"/>, with <c>ItemCanBeNullAttribute</c>.</returns>
        </member>
        <member name="T:Emik.Morsels.RandomizedGetters">
            <summary>Extension methods for randomized getters.</summary>
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.Shuffle``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Shuffles a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="selector">The indices to swap with, when left unspecified, uses <see cref="M:Emik.Morsels.RandomizedGetters.Rand"/>.</param>
            <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.RandomizedGetters.PickRandom``1(System.Collections.Generic.IEnumerable{``0},System.Func{System.Int32,System.Int32,System.Int32})">
            <summary>Shuffles a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to shuffle.</param>
            <param name="selector">The indices to swap with, when left unspecified, uses <see cref="M:Emik.Morsels.RandomizedGetters.Rand"/>.</param>
            <returns>A randomized list of items in the parameter <paramref name="selector"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Similarity">
            <summary>Provides methods for determining similarity between two sequences.</summary>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})">
            <summary>Calculates the Jaro similarity between two strings.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})">
            <summary>Calculates the Jaro-Winkler similarity between two strings.</summary>
            <remarks><para>Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})"/>, but with a bias to common prefixes.</para></remarks>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``1(System.Collections.Generic.IList{``0},System.Collections.Generic.IList{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})"/>, but with a bias to common prefixes.</para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``2(``0,``0,System.Func{``0,System.Int32},System.Func{``0,System.Int32,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Calculates the Jaro similarity between two sequences.</summary>
            <typeparam name="T">The type of sequence.</typeparam>
            <typeparam name="TItem">The type of item within the sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="counter">The function that gets the count.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``2(``0,``0,System.Func{``0,System.Int32},System.Func{``0,System.Int32,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Calculates the Jaro-Winkler similarity between two sequences.</summary>
            <remarks><para>Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})"/>, but with a bias to common prefixes.</para></remarks>
            <typeparam name="T">The type of sequence.</typeparam>
            <typeparam name="TItem">The type of item within the sequence.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="counter">The function that gets the count.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.Jaro``2(``0,``0,System.Int32,System.Int32,System.Func{``0,System.Int32,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Calculates the Jaro similarity between two instances.</summary>
            <typeparam name="T">The type of instance.</typeparam>
            <typeparam name="TItem">The type of item within the instance.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="leftLength">The left-hand side's length.</param>
            <param name="rightLength">The right-hand side's length.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="M:Emik.Morsels.Similarity.JaroWinkler``2(``0,``0,System.Int32,System.Int32,System.Func{``0,System.Int32,``1},System.Collections.Generic.IEqualityComparer{``1})">
            <summary>Calculates the Jaro-Winkler similarity between two instances.</summary>
            <remarks><para>Like <see cref="M:Emik.Morsels.Similarity.Jaro(System.String,System.String,System.Collections.Generic.IEqualityComparer{System.Char})"/>, but with a bias to common prefixes.</para></remarks>
            <typeparam name="T">The type of instance.</typeparam>
            <typeparam name="TItem">The type of item within the instance.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <param name="leftLength">The left-hand side's length.</param>
            <param name="rightLength">The right-hand side's length.</param>
            <param name="indexer">The function that acts as an indexer.</param>
            <param name="comparer">The comparer to determine equality, or <see cref="P:System.Collections.Generic.EqualityComparer`1.Default"/>.</param>
            <returns>Between 0.0 and 1.0 (higher value means more similar).</returns>
        </member>
        <member name="T:Emik.Morsels.SplitFactory">
            <summary>Extension methods that act as factories for <see cref="T:Emik.Morsels.Split`1"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.SplitFactory.SplitAt``1(System.Collections.Generic.ICollection{``0},System.Int32)">
            <summary>Splits an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in two based on a number.</summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="count">The number of elements in the first half.</param>
            <returns>
            A <see cref="T:Emik.Morsels.Split`1"/> instance that contains 2 enumerables containing the two halves of the underlying
            collection. The first half is as long as the parameter <paramref name="count"/> or shorter.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitFactory.SplitBy``1(System.Collections.Generic.IEnumerable{``0},System.Predicate{``0})">
            <summary>Splits an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in two based on a method provided.</summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="predicate">The method that decides where the item ends up.</param>
            <returns>
            A <see cref="T:Emik.Morsels.Split`1"/> instance that contains 2 lists containing the elements that returned
            <see langword="true"/> and <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.SplitFactory.SplitWhen``1(System.Collections.Generic.ICollection{``0},System.Func{``0,System.Boolean})">
            <summary>Splits an <see cref="T:System.Collections.Generic.IEnumerable`1"/> in two based on a method provided.</summary>
            <typeparam name="T">The type of the collection.</typeparam>
            <param name="source">The collection to split.</param>
            <param name="predicate">The method that decides where the item ends up.</param>
            <returns>
            A <see cref="T:Emik.Morsels.Split`1"/> instance that contains 2 enumerables containing the two halves of the underlying
            collection. The first half lasts until the first element that returned <see langword="true"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.Split`1">
            <summary>Represents a fixed collection of 2 items.</summary>
            <typeparam name="T">The type of item in the collection.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Split`1.#ctor(`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Split`1"/> class.</summary>
            <param name="value">The value representing both values.</param>
        </member>
        <member name="M:Emik.Morsels.Split`1.#ctor(`0,`0)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Split`1"/> class.</summary>
            <param name="truthy">The value representing a <see langword="true"/> value.</param>
            <param name="falsy">The value representing a <see langword="false"/> value.</param>
        </member>
        <member name="P:Emik.Morsels.Split`1.Falsy">
            <summary>Gets or sets the value representing a <see langword="false"/> value.</summary>
        </member>
        <member name="P:Emik.Morsels.Split`1.Truthy">
            <summary>Gets or sets the value representing a <see langword="true"/> value.</summary>
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="M:Emik.Morsels.Split`1.CopyTo(`0[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Contains(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Add(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Clear">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Clear" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{T}#Remove(`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.Values">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#IsReadOnly">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.IsReadOnly" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Count">
            <inheritdoc cref="P:System.Collections.Generic.ICollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#Keys">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.Item(System.Boolean)">
            <inheritdoc cref="P:System.Collections.Generic.IDictionary`2.Item(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.Add(System.Boolean,`0)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Add(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.CopyTo(System.Collections.Generic.KeyValuePair{System.Boolean,`0}[],System.Int32)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.Contains(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.TryGetValue(System.Boolean,`0@)">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.TryGetValue(`0,`1@)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Clear">
            <inheritdoc cref="M:System.Collections.Generic.ICollection`1.Clear" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#ICollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Remove(System.Collections.Generic.KeyValuePair{System.Boolean,`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#Remove(System.Boolean)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IDictionary{System#Boolean,T}#ContainsKey(System.Boolean)">
            <inheritdoc cref="M:System.Collections.Generic.IDictionary`2.ContainsKey(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IEnumerable{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyCollection{T}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyCollection{System#Collections#Generic#KeyValuePair{System#Boolean,T}}#Count">
            <inheritdoc cref="P:System.Collections.Generic.IReadOnlyCollection`1.Count" />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#Keys">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#Values">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Split`1.System#Collections#Generic#IReadOnlyDictionary{System#Boolean,T}#ContainsKey(System.Boolean)">
            <inheritdoc cref="M:System.Collections.Generic.IReadOnlyDictionary`2.ContainsKey(`0)" />
        </member>
        <member name="M:Emik.Morsels.Split`1.Deconstruct(`0@,`0@)">
            <summary>Deconstructs a <see cref="T:Emik.Morsels.Split`1"/> into its components.</summary>
            <param name="truthy">The value to get assigned as <see cref="P:Emik.Morsels.Split`1.Truthy"/>.</param>
            <param name="falsy">The value to get assigned as <see cref="P:Emik.Morsels.Split`1.Falsy"/>.</param>
        </member>
        <member name="M:Emik.Morsels.Split`1.ToString">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Conditionals">
            <summary>Extension methods for nullable types and booleans.</summary>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsAnd``1(``0,System.Predicate{``0})">
            <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="predicate">The predicate to determine the return value.</param>
            <returns>
            The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
            and returned <see langword="true"/> from the predicate, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsAnd``1(System.Nullable{``0},System.Predicate{``0})">
            <summary>Determines whether the inner value of a nullable value matches a given predicate.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="predicate">The predicate to determine the return value.</param>
            <returns>
            The value <see langword="true"/> if <paramref name="value"/> is not <see langword="null"/>
            and returned <see langword="true"/> from the predicate, otherwise <see langword="false"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsFalse(System.Boolean,System.String)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="that">The value that must be <see langword="false"/>.</param>
            <param name="exThat">Filled by the compiler, the expression to assert.</param>
            <returns>The parameter <paramref name="that"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.IsTrue(System.Boolean,System.String)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="that">The value that must be <see langword="true"/>.</param>
            <param name="exThat">Filled by the compiler, the expression to assert.</param>
            <returns>The parameter <paramref name="that"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.NotThen(System.Boolean,System.Action,System.Action)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="value">The value to check.</param>
            <param name="ifFalse">The value to invoke when <see langword="false"/>.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then(System.Boolean,System.Action,System.Action)">
            <summary>Conditionally invokes based on a condition.</summary>
            <param name="value">The value to check.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <param name="ifFalse">The value to invoke when <see langword="false"/>.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.NotThen``1(System.Boolean,``0)">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is eagerly evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="ifFalse">The value to return when <see langword="false"/>.</param>
            <returns>
            The value <paramref name="ifFalse"/> if <paramref name="value"/>
            is <see langword="false"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.NotThen``1(System.Boolean,System.Func{``0})">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is lazily evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="onFalse">The value to invoke when <see langword="false"/>.</param>
            <returns>
            The value returned from <paramref name="onFalse"/> if <paramref name="value"/>
            is <see langword="false"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then``1(System.Boolean,``0)">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is eagerly evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="onTrue">The value to return when <see langword="true"/>.</param>
            <returns>
            The value <paramref name="onTrue"/> if <paramref name="value"/>
            is <see langword="true"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Then``1(System.Boolean,System.Func{``0})">
            <summary>Gives an optional value based on a condition.</summary>
            <remarks><para>The parameter is lazily evaluated.</para></remarks>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to check.</param>
            <param name="ifTrue">The value to invoke when <see langword="true"/>.</param>
            <returns>
            The value returned from <paramref name="ifTrue"/> if <paramref name="value"/>
            is <see langword="true"/>, else <see langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Filter``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Filters an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to only non-null values.</summary>
            <typeparam name="T">The type of value to filter.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to filter.</param>
            <returns>A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> with strictly non-null values.</returns>
        </member>
        <member name="M:Emik.Morsels.Conditionals.Filter``1(System.Collections.Generic.IEnumerable{System.Nullable{``0}})">
            <summary>Filters an <see cref="T:System.Collections.Generic.IEnumerable`1"/> to only non-null values.</summary>
            <typeparam name="T">The type of value to filter.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to filter.</param>
            <returns>A filtered <see cref="T:System.Collections.Generic.IEnumerable`1"/> with strictly non-null values.</returns>
        </member>
        <member name="T:Emik.Morsels.Exit">
            <summary>Provides methods for exiting the program.</summary>
        </member>
        <member name="M:Emik.Morsels.Exit.Success(System.String)">
            <remarks><para>This method represents the exit code 0, indicating success.</para></remarks>
            <inheritdoc cref="M:Emik.Morsels.Exit.With(System.Byte,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Failure(System.String)">
            <remarks><para>This method represents the exit code 1, indicating failure.</para></remarks>
            <inheritdoc cref="M:Emik.Morsels.Exit.With(System.Byte,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Usage(System.String)">
            <remarks><para>This method represents the exit code 2, indicating invalid parameters.</para></remarks>
            <inheritdoc cref="M:Emik.Morsels.Exit.With(System.Byte,System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Success``1(System.String)">
            <typeparam name="T">Only used for type coercion.</typeparam>
            <inheritdoc cref="M:Emik.Morsels.Exit.Success(System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Failure``1(System.String)">
            <typeparam name="T">Only used for type coercion.</typeparam>
            <inheritdoc cref="M:Emik.Morsels.Exit.Failure(System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.Usage``1(System.String)">
            <typeparam name="T">Only used for type coercion.</typeparam>
            <inheritdoc cref="M:Emik.Morsels.Exit.Usage(System.String)"/>
        </member>
        <member name="M:Emik.Morsels.Exit.With(System.Byte,System.String)">
            <summary>Terminates this process and returns the exit code to the operating system.</summary>
            <param name="message">The message to print into the standard output/error, if specified.</param>
            <exception cref="T:System.Security.SecurityException">
            The caller does not have sufficient security permission to perform this function.
            </exception>
            <returns>This method does not return. Specified to allow <see keyword="throw"/> expressions.</returns>
        </member>
        <member name="T:Emik.Morsels.Peeks">
            <summary>Provides methods to use callbacks within a statement.</summary>
        </member>
        <member name="E:Emik.Morsels.Peeks.OnWrite">
            <summary>An event that is invoked every time <see cref="M:Emik.Morsels.Peeks.Write(System.String)"/> is called.</summary>
        </member>
        <member name="M:Emik.Morsels.Peeks.Shout(System.String)">
            <summary>
            Invokes <see cref="M:System.Diagnostics.Debug.WriteLine(System.String)"/>, and <see cref="M:System.Diagnostics.Trace.WriteLine(System.String)"/>.
            </summary>
            <remarks><para>
            This method exists to be able to hook both conditional methods in <see cref="E:Emik.Morsels.Peeks.OnWrite"/>,
            and to allow the consumer to be able to remove this method to the same <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.
            </para></remarks>
            <param name="message">The value to send a message.</param>
        </member>
        <member name="M:Emik.Morsels.Peeks.Write(System.String)">
            <summary>Quick and dirty debugging function, invokes <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.</summary>
            <param name="message">The value to send a message.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
        </member>
        <member name="M:Emik.Morsels.Peeks.Write``1(``0)">
            <summary>Quick and dirty debugging function, invokes <see cref="E:Emik.Morsels.Peeks.OnWrite"/>.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to stringify.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
        </member>
        <member name="M:Emik.Morsels.Peeks.Debug``1(``0,System.Boolean,System.Converter{``0,System.Object},System.Predicate{``0},System.Action{System.String},System.String,System.String,System.Int32,System.String)">
            <summary>Quick and dirty debugging function.</summary>
            <typeparam name="T">The type of value.</typeparam>
            <param name="value">The value to stringify and return.</param>
            <param name="shouldLogExpression">Determines whether <paramref name="expression"/> is logged.</param>
            <param name="map">The map callback.</param>
            <param name="filter">The filter callback.</param>
            <param name="logger">The logging callback.</param>
            <param name="expression">Automatically filled by compilers; the source code of <paramref name="value"/>.</param>
            <param name="path">Automatically filled by compilers; the file's path where this method was called.</param>
            <param name="line">Automatically filled by compilers; the line number where this method was called.</param>
            <param name="member">Automatically filled by compilers; the member's name where this method was called.</param>
            <exception cref="T:System.InvalidOperationException">
            <see cref="E:Emik.Morsels.Peeks.OnWrite"/> is <see langword="null"/>, which can only happen if
            every callback has been manually removed as it is always valid by default.
            </exception>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Peeks.Peek``1(``0,System.Action{``0})">
            <summary>Executes an <see cref="T:System.Action`1"/>, and returns the argument.</summary>
            <typeparam name="T">The type of value and action parameter.</typeparam>
            <param name="value">The value to pass into the callback.</param>
            <param name="action">The callback to perform.</param>
            <returns>The parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Peeks.Then``2(``0,System.Converter{``0,``1})">
            <summary>Executes the function, and returns the result.</summary>
            <typeparam name="T">The type of value and input parameter.</typeparam>
            <typeparam name="TResult">The type of output and return value.</typeparam>
            <param name="value">The value to pass into the callback.</param>
            <param name="converter">The callback to perform.</param>
            <returns>The return value of <paramref name="converter"/> after passing in <paramref name="value"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Unforgiving">
            <summary>Provides a reference for an <c>UnreachableException</c>.</summary>
        </member>
        <member name="P:Emik.Morsels.Unforgiving.CannotBeEmpty">
            <summary>Gets the <see cref="T:System.Exception"/> that a collection cannot be empty.</summary>
        </member>
        <member name="P:Emik.Morsels.Unforgiving.Unreachable">
            <summary>Gets the <see cref="T:System.Exception"/> that represents an unreachable state.</summary>
        </member>
        <member name="T:Emik.Morsels.Attachments">
            <summary>Adds support for Append and Prepend in lower frameworks.</summary>
        </member>
        <member name="M:Emik.Morsels.Attachments.Append``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Appends a value to the end of the sequence.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values.</param>
            <param name="element">The value to append to <paramref name="source"/>.</param>
            <returns>A new sequence that ends with <paramref name="element"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Attachments.Prepend``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Prepends a value to the end of the sequence.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source"/>.</typeparam>
            <param name="source">A sequence of values.</param>
            <param name="element">The value to prepend to <paramref name="source"/>.</param>
            <returns>A new sequence that starts with <paramref name="element"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Collected">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Collected.Collect``2(System.Collections.Generic.IEnumerable{``0},System.Converter{System.Collections.Generic.IEnumerable{``0},``1})">
            <summary>Attempts to create a list from an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</summary>
            <typeparam name="T">The type of item in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TList">The destination type.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to convert.</param>
            <param name="converter">The <see cref="T:System.Collections.Generic.IList`1"/> to convert it to.</param>
            <returns>
            A <typeparamref name="TList"/> from <paramref name="converter"/>, as long as every element returned
            is not <paramref langword="null"/>, otherwise <paramref langword="default"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Collected.ToCollectionLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Upcasts or creates an <see cref="T:System.Collections.Generic.ICollection`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to upcast or encapsulate.</param>
            <returns>Itself as <see cref="T:System.Collections.Generic.ICollection`1"/>, or a collected <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Collected.ToListLazily``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Upcasts or creates an <see cref="T:System.Collections.Generic.IList`1"/>.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to upcast or encapsulate.</param>
            <returns>Itself as <see cref="T:System.Collections.Generic.IList`1"/>, or a collected <see cref="T:System.Array"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Each">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32,System.Action)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32,System.Action{System.Int32})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0,System.Action{``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0,System.Action{System.Int32,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{``0,``1,``2})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Action{``0,``1,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Action{``0,``1,System.Int32,``2})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For(System.Int32)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="num">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.GetEnumerator(System.Int32)">
            <summary>Gets an enumeration of a number.</summary>
            <param name="num">The index to count up or down to.</param>
            <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,``0)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> of <see cref="T:System.Int32"/> from ranges 0 to <paramref name="upper"/> - 1.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,System.Func{``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TResult">The type of iterator.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The function for each loop.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Each.For``1(System.Int32,System.Converter{System.Int32,``0})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TResult">The type of iterator.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The function for each loop.</param>
            <returns>All instances that <paramref name="func"/> used in an <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.EachLazy">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``1(System.Collections.Generic.IEnumerable{``0},System.Action{``0,System.Int32})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachLazy.Lazily``2(System.Collections.Generic.IEnumerable{``0},``1,System.Action{``0,System.Int32,``1})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="action">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Enumerable`2">
            <summary>
            Defines an <see cref="T:System.Collections.Generic.IEnumerable`1"/> with a <see cref="T:System.Delegate"/> that is invoked on iteration.
            </summary>
            <typeparam name="T">The type of item in the <see cref="T:System.Collections.Generic.IEnumerable`1"/>.</typeparam>
            <typeparam name="TExternal">The context element to pass into the <see cref="T:System.Delegate"/>.</typeparam>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,`1})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Action{`0,System.Int32,`1})">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.#ctor(System.Collections.Generic.IEnumerable{`0},`1,System.Delegate)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Morsels.Enumerable`2"/> class.</summary>
            <param name="enumerable">
            The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to create an <see cref="T:System.Collections.Generic.IEnumerator`1"/> from.
            </param>
            <param name="external">The context element.</param>
            <param name="action">The <see cref="T:System.Delegate"/> to invoke on iteration.</param>
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.GetEnumerator">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.System#Collections#IEnumerable#GetEnumerator">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Enumerable`2.Enumerator.Current">
            <inheritdoc />
        </member>
        <member name="P:Emik.Morsels.Enumerable`2.Enumerator.System#Collections#IEnumerator#Current">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.Reset">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.Dispose">
            <inheritdoc />
        </member>
        <member name="M:Emik.Morsels.Enumerable`2.Enumerator.MoveNext">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.EachWithControlFlow">
            <summary>Similar to <see cref="T:Emik.Morsels.Each"/>, but with control flow, using <see cref="T:Emik.Morsels.ControlFlow"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For(System.Int32,System.Func{Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For(System.Int32,System.Func{System.Int32,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="func">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``1(System.Int32,``0,System.Func{``0,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``1(System.Int32,``0,System.Func{System.Int32,``0,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="upper">The length to reach to in the for loop.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action for each loop.</param>
            <returns>The parameter <paramref name="upper"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,``1,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``2(System.Collections.Generic.IEnumerable{``0},``1,System.Func{``0,System.Int32,``1,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="T">The type of iterator.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action to do on each item in <paramref name="iterable"/>.</param>
            <returns>The parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{``0,``1,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Func{``0,``1,``2,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``2(System.Collections.Generic.IDictionary{``0,``1},System.Func{``0,``1,System.Int32,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EachWithControlFlow.For``3(System.Collections.Generic.IDictionary{``0,``1},``2,System.Func{``0,``1,System.Int32,``2,Emik.Morsels.ControlFlow})">
            <summary>
            The <see langword="foreach"/> statement executes a statement or a block of statements for each element in an
            instance of the type that implements the <see cref="T:System.Collections.IEnumerable"/> or <see cref="T:System.Collections.Generic.IEnumerable`1"/> interface.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-foreach-statement.</para></remarks>
            <typeparam name="TKey">The type of key in the dictionary.</typeparam>
            <typeparam name="TValue">The type of value in the dictionary.</typeparam>
            <typeparam name="TExternal">The type of external parameter to pass into the callback.</typeparam>
            <param name="dictionary">The collection of items to go through one-by-one.</param>
            <param name="external">Any external parameter to be passed repeatedly into the callback.</param>
            <param name="func">The action to do on each item in <paramref name="dictionary"/>.</param>
            <returns>The parameter <paramref name="dictionary"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ControlFlow">
            <summary>Determines control flow for loops in <see cref="T:Emik.Morsels.Each"/>.</summary>
        </member>
        <member name="F:Emik.Morsels.ControlFlow.Continue">
            <summary>The value indicating that the loop should continue.</summary>
        </member>
        <member name="F:Emik.Morsels.ControlFlow.Break">
            <summary>The value indicating that the loop should break.</summary>
        </member>
        <member name="T:Emik.Morsels.Force">
            <summary>Extension methods to force full enumerations.</summary>
        </member>
        <member name="M:Emik.Morsels.Force.Enumerate(System.Collections.IEnumerable)">
            <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
            <param name="iterable">The collection of items to go through one-by-one.</param>
        </member>
        <member name="M:Emik.Morsels.Force.Enumerate``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Forces an enumeration, meant for enumerations that have side effects.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
        </member>
        <member name="T:Emik.Morsels.Indexers">
            <summary>Extension methods for iterating over a set of elements, or for generating new ones.</summary>
        </member>
        <member name="M:Emik.Morsels.Indexers.For(System.Index)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="index">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.For(System.Range)">
            <summary>
            The <see langword="for"/> statement executes a statement or a block of statements while a specified
            Boolean expression evaluates to <see langword="true"/>.
            </summary>
            <remarks><para>https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/statements/iteration-statements#the-for-statement.</para></remarks>
            <param name="range">The range of numbers to iterate over in the <see langword="for"/> loop.</param>
            <returns>An enumeration from a range's start to end.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Index)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Range)">
            <summary>Gets a range of items from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get a range of items from.</param>
            <param name="range">The ranges to get.</param>
            <returns>A slice from the parameter <paramref name="iterable"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.GetEnumerator(System.Index)">
            <summary>Gets an enumeration of an index.</summary>
            <param name="index">The index to count up or down to.</param>
            <returns>An enumeration from 0 to the index's value, or vice versa.</returns>
        </member>
        <member name="M:Emik.Morsels.Indexers.GetEnumerator(System.Range)">
            <summary>Gets an enumeration of a range.</summary>
            <param name="range">The range to iterate over.</param>
            <returns>An enumeration from the range's start to end.</returns>
        </member>
        <member name="T:Emik.Morsels.NegatedEnumerable">
            <summary>Extension methods that negate functions from <see cref="T:System.Linq.Enumerable"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.DistinctDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.</summary>
            <remarks><para>
            Filters out unique elements within an <see cref="!:Enumerable&lt;T&gt;"/>.
            Each duplicate appears exactly once within the returned value.
            </para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> and <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</typeparam>
            <param name="source">The source to filter.</param>
            <param name="comparer">The comparer to assess distinctiveness.</param>
            <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.Duplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.</summary>
            <remarks><para>
            Filters out unique elements within an <see cref="!:Enumerable&lt;T&gt;"/>.
            Each duplicate appears two or more times within the returned value.
            </para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> and <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</typeparam>
            <param name="source">The source to filter.</param>
            <param name="comparer">The comparer to assess distinctiveness.</param>
            <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.GroupDuplicates``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Distinct``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEqualityComparer{``0})"/>.</summary>
            <remarks><para>Filters out unique elements within an <see cref="!:Enumerable&lt;T&gt;"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Collections.Generic.IEnumerable`1"/> and <see cref="T:System.Collections.Generic.IEqualityComparer`1"/>.</typeparam>
            <param name="source">The source to filter.</param>
            <param name="comparer">The comparer to assess distinctiveness.</param>
            <returns>The parameter <paramref name="source"/>, filtering out all elements that only appear once.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.SkipUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements from the input sequence starting at
            the first element in the linear series that does pass the test specified by the predicate.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.SkipWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.TakeUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains the elements from the input
            sequence that occur before the element at which the test no longer fails.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.TakeUntil``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.TakeWhile``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.ToEnumerable(System.Collections.IEnumerator)">
            <summary>
            Negated <see cref="M:System.Collections.IEnumerable.GetEnumerator"/>.
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <param name="iterator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to encapsulate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.ToEnumerable``1(System.Collections.Generic.IEnumerator{``0})">
            <summary>
            Negated <see cref="M:System.Collections.Generic.IEnumerable`1.GetEnumerator"/>.
            Creates an <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating an <see cref="T:System.Collections.Generic.IEnumerator`1"/>.
            </summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterator">The <see cref="T:System.Collections.Generic.IEnumerator`1"/> to encapsulate.</param>
            <returns>An <see cref="T:System.Collections.Generic.IEnumerable`1"/> encapsulating the parameter <paramref name="iterator"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.Omit``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Boolean})"/>
        </member>
        <member name="M:Emik.Morsels.NegatedEnumerable.Omit``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})">
            <summary>Negated <see cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>.</summary>
            <returns>
            An <see cref="T:System.Collections.Generic.IEnumerable`1" /> that contains elements from
            the input sequence that do not satisfy the condition.
            </returns>
            <inheritdoc cref="M:System.Linq.Enumerable.Where``1(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Boolean})"/>
        </member>
        <member name="T:Emik.Morsels.PowerSetFactories">
            <summary>Extension methods to create power sets.</summary>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet(System.Collections.ICollection)">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})">
            <summary>Creates a power set from a collection.</summary>
            <remarks><para>
            The power set is defined as the set of all subsets, including the empty set and the set itself.
            </para></remarks>
            <typeparam name="T">The type of item in the set.</typeparam>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The argument <paramref name="collection"/> has 32 or more elements.
            </exception>
            <param name="collection">The set to create a power set.</param>
            <returns>The power set of the parameter <paramref name="collection"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.IReadOnlyCollection{``0})">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="M:Emik.Morsels.PowerSetFactories.PowerSet``1(``0[])">
            <inheritdoc cref="M:Emik.Morsels.PowerSetFactories.PowerSet``1(System.Collections.Generic.ICollection{``0})"/>
        </member>
        <member name="T:Emik.Morsels.TryTake">
            <summary>Extension methods to attempt to grab values from enumerables.</summary>
        </member>
        <member name="M:Emik.Morsels.TryTake.TryCount``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Attempts to determine the number of elements in a sequence without forcing an enumeration.</summary>
            <typeparam name="TSource">The type of the elements of <paramref name="source" />.</typeparam>
            <param name="source">A sequence that contains elements to be counted.</param>
            <remarks><para>
            The method performs a series of type tests, identifying common subtypes whose
            count can be determined without enumerating; this includes <see cref="T:System.Collections.Generic.ICollection`1"/>,
            <see cref="T:System.Collections.ICollection"/>, and <see cref="T:System.Collections.Generic.IReadOnlyCollection`1"/>.
            </para><para>
            The method is typically a constant-time operation, but ultimately this depends on the complexity
            characteristics of the underlying collection implementation.
            </para></remarks>
            <returns>The length of the collection if pre-computed, or <see langword="null"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.EnumerateOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the last item lazily, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.FirstOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the first item, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The first item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.LastOr``1(System.Collections.Generic.IEnumerable{``0},``0)">
            <summary>Takes the last item, or a fallback value.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The collection of items to go through one-by-one.</param>
            <param name="fallback">The fallback item.</param>
            <returns>The last item, or the parameter <paramref name="fallback"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Nth``2(System.Collections.Generic.IDictionary{``0,``1},``0)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="TKey">The key item in the collection.</typeparam>
            <typeparam name="TValue">The value item in the collection.</typeparam>
            <param name="dictionary">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="key">The key to use to get the value.</param>
            <returns>An element from the parameter <paramref name="dictionary"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.OrEmpty``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>Returns the enumeration, or an empty enumeration.</summary>
            <typeparam name="T">The type of iterator.</typeparam>
            <param name="iterable">The enumeration to potentially return.</param>
            <returns>The parameter <paramref name="iterable"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.Nth``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TryTake.NthLast``1(System.Collections.Generic.IEnumerable{``0},System.Int32)">
            <summary>Gets a specific item from a collection.</summary>
            <typeparam name="T">The item in the collection.</typeparam>
            <param name="iterable">The <see cref="T:System.Collections.Generic.IEnumerable`1"/> to get an item from.</param>
            <param name="index">The index to get.</param>
            <returns>An element from the parameter <paramref name="iterable"/>, or <see langword="default"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.ManyQueries">
            <summary>Methods that creates enumerations from individual items.</summary>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(``0,System.Converter{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="item">The item to check.</param>
            <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Nullable{``0},System.Converter{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>Uses the callback if the parameter is non-<see langword="null"/>.</summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="item">The item to check.</param>
            <param name="map">The callback to use when <paramref name="item"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{``1}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.ManyQueries.ManyOrEmpty``2(System.Collections.Generic.IEnumerable{System.Nullable{``0}},System.Func{``0,System.Int32,System.Collections.Generic.IEnumerable{System.Nullable{``1}}})">
            <summary>
            <see cref="M:System.Linq.Enumerable.SelectMany``2(System.Collections.Generic.IEnumerable{``0},System.Func{``0,System.Collections.Generic.IEnumerable{``1}})"/>
            but with exhaustive null guards that fall back to empty enumerables.
            </summary>
            <typeparam name="T">The source of the item.</typeparam>
            <typeparam name="TResult">The resulting type.</typeparam>
            <param name="iterator">The item to check.</param>
            <param name="map">The callback to use when <paramref name="iterator"/> is non-<see langword="null"/>.</param>
            <returns>The result of the parameter <paramref name="map"/>, or <see cref="M:System.Linq.Enumerable.Empty``1"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.MethodGroupings">
            <summary>Methods to create methods.</summary>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Invoke(System.Action)">
            <summary>Invokes a method.</summary>
            <param name="del">The method to invoke.</param>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action(System.Action)">
            <summary>Create a delegate.</summary>
            <param name="del">The method group.</param>
            <returns>An invokable method.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action1``1(System.Action{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action2``2(System.Action{``0,``1})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action3``3(System.Action{``0,``1,``2})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Action4``4(System.Action{``0,``1,``2,``3})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func``1(System.Func{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func1``2(System.Func{``0,``1})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func2``3(System.Func{``0,``1,``2})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func3``4(System.Func{``0,``1,``2,``3})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Func4``5(System.Func{``0,``1,``2,``3,``4})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Action(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not1``1(System.Func{``0,System.Boolean})">
            <summary>Negates a predicate.</summary>
            <typeparam name="T">The type of item for the predicate.</typeparam>
            <param name="predicate">The predicate to negate.</param>
            <returns>The argument <paramref name="predicate"/> wrapped in another that negates its result.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not2``1(System.Func{``0,System.Int32,System.Boolean})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Comparing``2(System.Converter{``0,``1},System.Collections.Generic.Comparer{``1})">
            <summary>Creates the <see cref="T:System.Collections.Generic.IComparer`1"/> from the mapping.</summary>
            <typeparam name="T">The type to compare.</typeparam>
            <typeparam name="TResult">The resulting value from the mapping used for comparison.</typeparam>
            <param name="converter">The converter to use.</param>
            <param name="comparer">If specified, the way the result of the delegate should be sorted.</param>
            <returns>The <see cref="T:System.Collections.Generic.IComparer`1"/> that wraps the parameter <paramref name="converter"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Not``1(System.Predicate{``0})"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Invoke``1(System.Func{``0})">
            <inheritdoc cref="M:Emik.Morsels.MethodGroupings.Invoke(System.Action)"/>
        </member>
        <member name="M:Emik.Morsels.MethodGroupings.Comparer`2.Compare(`0,`0)">
            <inheritdoc />
        </member>
        <member name="T:Emik.Morsels.Clamped">
            <summary>Extension methods to clamp numbers.</summary>
        </member>
        <member name="M:Emik.Morsels.Clamped.Clamp(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})">
            <summary>Clamps a value such that it is no smaller or larger than the defined amount.</summary>
            <param name="number">The number to clip.</param>
            <param name="min">If specified, the smallest number to return.</param>
            <param name="max">If specified, the greatest number to return.</param>
            <returns>
            The parameter <paramref name="min"/> if <paramref name="number"/> is smaller than <paramref name="min"/>,
            otherwise, the parameter <paramref name="max"/> if <paramref name="number"/> is greater than
            <paramref name="max"/>, otherwise the parameter <paramref name="number"/>.
            </returns>
        </member>
        <member name="M:Emik.Morsels.Clamped.Clamp(System.Single,System.Nullable{System.Single},System.Nullable{System.Single})">
            <inheritdoc cref="M:Emik.Morsels.Clamped.Clamp(System.Int32,System.Nullable{System.Int32},System.Nullable{System.Int32})"/>
        </member>
        <member name="T:Emik.Morsels.EnumMath">
            <summary>Provides methods to do math on enums without overhead from boxing.</summary>
        </member>
        <member name="M:Emik.Morsels.EnumMath.AsInt``1(``0)">
            <summary>Performs a conversion operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The <see cref="T:System.Int32"/> cast of <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.As``1(System.Int32)">
            <summary>Performs a conversion operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The <typeparamref name="T"/> cast of <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Negate``1(``0)">
            <summary>Performs a negation operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The negated value of the parameter <paramref name="value"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Predecessor``1(``0)">
            <summary>Performs an decrement operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately before it.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Successor``1(``0)">
            <summary>Performs a increment operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="value">The value.</param>
            <returns>The predecessor of the parameter <paramref name="value"/>; the number immediately after it.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Add``1(``0,``0)">
            <summary>Performs an addition operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The sum of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Subtract``1(``0,``0)">
            <summary>Performs a subtraction operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The difference of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Multiply``1(``0,``0)">
            <summary>Performs a multiplication operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The product of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Divide``1(``0,``0)">
            <summary>Performs a division operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The quotient of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.EnumMath.Modulo``1(``0,``0)">
            <summary>Performs a modulo operation.</summary>
            <remarks><para>The conversion and operation are unchecked, and treated as <see cref="T:System.Int32"/>.</para></remarks>
            <typeparam name="T">The type of <see cref="T:System.Enum"/> to perform the operation on.</typeparam>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>The remainder of the parameters <paramref name="left"/> and <paramref name="right"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.Heap">
            <summary>Provides methods for heap-allocation analysis.</summary>
        </member>
        <member name="F:Emik.Morsels.Heap.NotForProduction">
            <summary>
            A <see langword="string"/> to use in an <see cref="T:System.ObsoleteAttribute"/> to indicate that the API isn't meant
            for production, but not for deprecated reasons.
            </summary>
        </member>
        <member name="M:Emik.Morsels.Heap.Swallow(System.Action)">
            <summary>Swallows all exceptions from a callback; Use with caution.</summary>
            <param name="action">The dangerous callback.</param>
        </member>
        <member name="M:Emik.Morsels.Heap.CountAllocation(System.Action,System.Boolean)">
            <summary>Gets the amount of bytes a callback uses.</summary>
            <remarks><para>
            This method temporarily tunes the <see cref="T:System.GC"/> to <see cref="F:System.Runtime.GCLatencyMode.LowLatency"/>
            for accurate results. As such, the parameter <paramref name="heap"/> should not cause
            substantial allocation such that collecting mid-way is required.
            </para></remarks>
            <param name="heap">The callback that causes some amount of heap allocation.</param>
            <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
            <returns>The number of bytes the <see cref="T:System.GC"/> allocated from calling <paramref name="heap"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Heap.CountAllocations(System.Action,System.Int32,System.Boolean)">
            <summary>Gets multiple instances of the amount of bytes a callback uses.</summary>
            <param name="heap">The callback that causes some amount of heap allocation.</param>
            <param name="times">The amount of times to invoke <paramref name="heap"/>.</param>
            <param name="willWarmup">Whether it should call the method once to initialize static/lazy-based values.</param>
            <returns>
            An <see cref="T:System.Array"/> where each entry is a separate test of the number of
            bytes the <see cref="T:System.GC"/> allocated from calling <paramref name="heap"/>.
            </returns>
        </member>
        <member name="T:Emik.Morsels.CharacterInvariance">
            <summary>Provides extension methods for <see cref="T:System.Char"/>.</summary>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsControl(System.Char)">
            <inheritdoc cref="M:System.Char.IsControl(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsDigit(System.Char)">
            <inheritdoc cref="M:System.Char.IsDigit(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsHighSurrogate(System.Char)">
            <inheritdoc cref="M:System.Char.IsHighSurrogate(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsLetter(System.Char)">
            <inheritdoc cref="M:System.Char.IsLetter(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsLetterOrDigit(System.Char)">
            <inheritdoc cref="M:System.Char.IsLetterOrDigit(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsLower(System.Char)">
            <inheritdoc cref="M:System.Char.IsLower(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsLowSurrogate(System.Char)">
            <inheritdoc cref="M:System.Char.IsLowSurrogate(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsNullOrEmpty(System.String)">
            <inheritdoc cref="M:System.String.IsNullOrEmpty(System.String)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsNullOrWhitespace(System.String)">
            <summary>
            Indicates whether a specified string is <see langword="null"/>,
            empty, or consists only of white-space characters.
            </summary>
            <param name="value">The string to test.</param>
            <returns>
            <see langword="true"/> if the <paramref name="value"/> parameter is <see langword="null"/>,
            or <see cref="F:System.String.Empty"/>, or if <paramref name="value"/> consists exclusively of white-space characters.
            </returns>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsNumber(System.Char)">
            <inheritdoc cref="M:System.Char.IsNumber(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsPunctuation(System.Char)">
            <inheritdoc cref="M:System.Char.IsPunctuation(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsSeparator(System.Char)">
            <inheritdoc cref="M:System.Char.IsSeparator(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsSurrogate(System.Char)">
            <inheritdoc cref="M:System.Char.IsSurrogate(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsSymbol(System.Char)">
            <inheritdoc cref="M:System.Char.IsSymbol(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsUpper(System.Char)">
            <inheritdoc cref="M:System.Char.IsUpper(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.IsWhitespace(System.Char)">
            <inheritdoc cref="M:System.Char.IsWhiteSpace(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.AsDigit(System.Char)">
            <summary>Converts the character to the byte-equivalent, 0-9.</summary>
            <param name="c">The character to convert.</param>
            <exception cref="T:System.ArgumentOutOfRangeException">
            The parameter <paramref name="c"/> isn't between '0' and '9', inclusively on both ends.
            </exception>
            <returns>The number 0-9 representing the character.</returns>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.TryAsDigit(System.Char)">
            <summary>Attempts to convert the character to the byte-equivalent, 0-9.</summary>
            <param name="c">The character to convert.</param>
            <returns>The number 0-9 representing the character, or <see langword="null"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.ToLower(System.Char)">
            <inheritdoc cref="M:System.Char.ToLower(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.ToUpper(System.Char)">
            <inheritdoc cref="M:System.Char.ToUpper(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.GetNumericValue(System.Char)">
            <inheritdoc cref="M:System.Char.GetNumericValue(System.Char)"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.Trim(System.String,System.String)">
            <inheritdoc cref="M:System.String.Trim(System.Char[])"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.TrimEnd(System.String,System.String)">
            <inheritdoc cref="M:System.String.TrimEnd(System.Char[])"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.TrimStart(System.String,System.String)">
            <inheritdoc cref="M:System.String.TrimStart(System.Char[])"/>
        </member>
        <member name="M:Emik.Morsels.CharacterInvariance.GetUnicodeCategory(System.Char)">
            <inheritdoc cref="M:System.Char.GetUnicodeCategory(System.Char)"/>
        </member>
        <member name="T:Emik.Morsels.Stringifier">
            <summary>Provides stringification methods.</summary>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.Char)">
            <summary>Joins a set of values into one long <see cref="T:System.String"/>.</summary>
            <remarks><para>
            This method is more efficient than using
            <see cref="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.String)"/> for <see cref="T:System.Char"/> separators.
            </para></remarks>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>One long <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Conjoin``1(System.Collections.Generic.IEnumerable{``0},System.String)">
            <summary>Joins a set of values into one long <see cref="T:System.String"/>.</summary>
            <typeparam name="T">The type of each item in the collection.</typeparam>
            <param name="values">The values to join.</param>
            <param name="separator">The separator between each item.</param>
            <returns>One long <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Nth(System.Int32,System.Boolean)">
            <summary>Converts a number to an ordinal.</summary>
            <param name="i">The number to convert.</param>
            <param name="indexByZero">Determines whether to index from zero or one.</param>
            <returns>The parameter <paramref name="i"/> as an ordinal.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Stringify``1(``0)">
            <summary>
            Converts <paramref name="source"/> into a <see cref="T:System.String"/> representation of <paramref name="source"/>.
            </summary>
            <remarks><para>
            Unlike <see cref="M:System.Object.ToString"/>, the values of all properties are printed out,
            unless they explicitly define a <see cref="M:System.Object.ToString"/>, or inherit <see cref="T:System.Collections.IEnumerable"/>,
            in which case each item within is printed out separately.
            </para></remarks>
            <typeparam name="T">The type of the source.</typeparam>
            <param name="source">The item to get a <see cref="T:System.String"/> representation of.</param>
            <returns><paramref name="source"/> as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.Stringifier.Stringify``1(``0,System.Boolean,System.Boolean)">
            <summary>
            Converts <paramref name="source"/> into a <see cref="T:System.String"/> representation of <paramref name="source"/>.
            </summary>
            <remarks><para>
            Unlike <see cref="M:System.Object.ToString"/>, the values of all properties are printed out,
            unless they explicitly define a <see cref="M:System.Object.ToString"/>, or inherit <see cref="T:System.Collections.IEnumerable"/>,
            in which case each item within is printed out separately.
            </para></remarks>
            <typeparam name="T">The type of the source.</typeparam>
            <param name="source">The item to get a <see cref="T:System.String"/> representation of.</param>
            <param name="isSurrounded">
            Determines whether <see cref="T:System.String"/> and <see cref="T:System.Char"/> have a " and ' surrounding them.
            </param>
            <param name="isRecursive">
            Determines whether it re-calls <see cref="M:Emik.Morsels.Stringifier.Stringify``1(``0,System.Boolean,System.Boolean)"/>
            on each property in <paramref name="source"/>.
            </param>
            <returns><paramref name="source"/> as <see cref="T:System.String"/>.</returns>
        </member>
        <member name="T:Emik.Morsels.TupleExtracts">
            <summary>Methods to get elements of a tuple.</summary>
        </member>
        <member name="M:Emik.Morsels.TupleExtracts.First``2(System.ValueTuple{``0,``1})">
            <summary>Gets the first item of the tuple.</summary>
            <typeparam name="T1">The first type of the tuple.</typeparam>
            <typeparam name="T2">The second type of the tuple.</typeparam>
            <param name="tuple">The tuple to get the value from.</param>
            <returns>The field <see cref="F:System.ValueTuple`2.Item1"/> from the parameter <paramref name="tuple"/>.</returns>
        </member>
        <member name="M:Emik.Morsels.TupleExtracts.Second``2(System.ValueTuple{``0,``1})">
            <summary>Gets the second item of the tuple.</summary>
            <typeparam name="T1">The first type of the tuple.</typeparam>
            <typeparam name="T2">The second type of the tuple.</typeparam>
            <param name="tuple">The tuple to get the value from.</param>
            <returns>The field <see cref="F:System.ValueTuple`2.Item2"/> from the parameter <paramref name="tuple"/>.</returns>
        </member>
        <member name="T:Emik.Numerics.Fractions.Fraction">
            <summary>Represents a fractional value.</summary>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.#ctor(System.Int64,System.Int64)">
            <summary>Initializes a new instance of the <see cref="T:Emik.Numerics.Fractions.Fraction"/> struct.</summary>
            <param name="numerator">The numerator of this value.</param>
            <param name="denominator">The denominator of this value. Cannot be zero.</param>
            <exception cref="T:System.DivideByZeroException">The parameter <paramref name="denominator"/> is 0.</exception>
        </member>
        <member name="P:Emik.Numerics.Fractions.Fraction.MaxValue">
            <summary>Gets the value representing the maximum possible value.</summary>
        </member>
        <member name="P:Emik.Numerics.Fractions.Fraction.MinValue">
            <summary>Gets the value representing the minimum possible value.</summary>
        </member>
        <member name="P:Emik.Numerics.Fractions.Fraction.NegativeOne">
            <summary>Gets the value representing negative one.</summary>
        </member>
        <member name="P:Emik.Numerics.Fractions.Fraction.One">
            <summary>Gets the value representing one.</summary>
        </member>
        <member name="P:Emik.Numerics.Fractions.Fraction.Zero">
            <summary>Gets the value representing zero.</summary>
        </member>
        <member name="P:Emik.Numerics.Fractions.Fraction.Radix">
            <summary>Gets the radix of this type.</summary>
        </member>
        <member name="P:Emik.Numerics.Fractions.Fraction.Denominator">
            <summary>Gets the denominator.</summary>
        </member>
        <member name="P:Emik.Numerics.Fractions.Fraction.Numerator">
            <summary>Gets the numerator.</summary>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.IsEvenInteger(Emik.Numerics.Fractions.Fraction)">
            <summary>Determines whether the value is even.</summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/> if even, <see langword="false"/>.</returns>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.IsNegative(Emik.Numerics.Fractions.Fraction)">
            <summary>Determines whether the value is negative.</summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/> if negative, <see langword="false"/>.</returns>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.IsOddInteger(Emik.Numerics.Fractions.Fraction)">
            <summary>Determines whether the value is odd.</summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/> if odd, <see langword="false"/>.</returns>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.IsPositive(Emik.Numerics.Fractions.Fraction)">
            <summary>Determines whether the value is positive.</summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/> if positive, <see langword="false"/>.</returns>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.IsPow2(Emik.Numerics.Fractions.Fraction)">
            <summary>Determines whether the value is a power of two.</summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/> if a power of two; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.IsZero(Emik.Numerics.Fractions.Fraction)">
            <summary>Determines whether the value is zero.</summary>
            <param name="value">The value to check.</param>
            <returns><see langword="true"/> if zero; otherwise, <see langword="false"/>.</returns>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.TryParse(System.String,System.IFormatProvider,Emik.Numerics.Fractions.Fraction@)">
            <inheritdoc cref="M:System.Int64.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)"/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,Emik.Numerics.Fractions.Fraction@)">
            <inheritdoc cref="M:System.Int64.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Int64@)"/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Abs(Emik.Numerics.Fractions.Fraction)">
            <inheritdoc cref="M:System.Math.Abs(System.Int32)"/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Min(Emik.Numerics.Fractions.Fraction,Emik.Numerics.Fractions.Fraction)">
            <inheritdoc cref="M:System.Math.Max(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Max(Emik.Numerics.Fractions.Fraction,Emik.Numerics.Fractions.Fraction)">
            <inheritdoc cref="M:System.Math.Max(System.Int32,System.Int32)"/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Parse(System.String,System.IFormatProvider)">
            <inheritdoc cref="M:System.Int64.Parse(System.String,System.IFormatProvider)"/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)">
            <inheritdoc cref="M:System.Int64.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)"/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Equals(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Deconstruct(System.Int64@,System.Int64@)">
            <summary>Deconstructs the instance with its components.</summary>
            <param name="numerator">The numerator of this value.</param>
            <param name="denominator">The denominator of this value. Will not be zero.</param>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Equals(Emik.Numerics.Fractions.Fraction)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Equals(Emik.Numerics.Fractions.Fraction,Emik.Numerics.Fractions.Fraction)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.GetHashCode(Emik.Numerics.Fractions.Fraction)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.CompareTo(System.Object)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.CompareTo(Emik.Numerics.Fractions.Fraction)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.GetHashCode">
            <inheritdoc />
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToString">
            <inheritdoc />
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToString(System.String,System.IFormatProvider)">
            <inheritdoc />
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToBoolean(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToByte(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToChar(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToDecimal(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToDouble(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToInt16(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToInt32(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToInt64(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToSByte(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToSingle(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToString(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToType(System.Type,System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToUInt16(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToUInt32(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToUInt64(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.ToDateTime(System.IFormatProvider)">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.GetTypeCode">
            <inheritdoc/>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.Simplify(System.Int64@,System.Int64@)">
            <summary>Simplifies the numbers before being passed to the fraction.</summary>
            <param name="numerator">The numerator to simplify.</param>
            <param name="denominator">The denominator to simplify.</param>
        </member>
        <member name="M:Emik.Numerics.Fractions.Fraction.GreatestCommonDenominator(System.Int64,System.Int64)">
            <summary>Gets the greatest common denominator between two numbers.</summary>
            <param name="left">The left-hand side.</param>
            <param name="right">The right-hand side.</param>
            <returns>
            The greatest common denominator of the parameters <paramref name="left"/> and <paramref name="right"/>.
            </returns>
        </member>
        <member name="T:InlineMethod.InlineAttribute">
            <summary>Method to inline.</summary>
        </member>
        <member name="M:InlineMethod.InlineAttribute.#ctor(System.Boolean)">
            <summary>Initializes a new instance of the <see cref="T:InlineMethod.InlineAttribute"/> class.</summary>
            <param name="remove">The value to set.</param>
        </member>
        <member name="P:InlineMethod.InlineAttribute.Remove">
            <summary>Gets a value indicating whether to remove the method after inlining, if private.</summary>
        </member>
    </members>
</doc>
